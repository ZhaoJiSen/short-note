---
title: match 控制结构
createTime: 2025/09/26 17:45:17
permalink: /rust/hpzb7ag9/
---

### match 匹配

`match` 匹配允许将一个值域一系列的模块相比较，并根据匹配模式执行对应代码。使用方式：

1. `match` 后紧跟一个表达式，该表达式返回值可以是任意类型，但需要与分支中的模式匹配。
2. `match` 分支由两部分组成：==模式与针对该模式的处理代码==，二者通过 `=>` 分开。
3. `match` 表达式执行时，会按顺序将表达式的值与每个分支中的模式进行比较，如果模式匹配，则执行对应分支中的代码，分支中代码的执行结果将作为整个 `match` 表达式的返回值。

```rust
enum Coin {
  Penny,
  Nickel,
  Dime,
  Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
  match coin {
    Coin::Penny =>  {
      println!("Lucky penny!");
      1
    },
    Coin::Nickel => 5,
    Coin::Dime => 10,
    Coin::Quarter => 25,
  }
}
```

::: details
`match` 本身也是一个表达式，因此可以使用它进行赋值，例如：

```rust
enum IpAddr {
   Ipv4,
   Ipv6
}

fn main() {
    let ip1 = IpAddr::Ipv6;
    let ip_str = match ip1 {
        IpAddr::Ipv4 => "127.0.0.1",
        _ => "::1",
    };

    println!("{}", ip_str);
}
```

:::

#### 模式绑定

匹配模式的另外一个作用就是从模式中取出绑定的值

```rust
enum Action {
  Say(String),
  MoveTo(i32, i32),
  ChangeColorRGB(u16, u16, u16),
}

fn main () {
  let actions = [
    Action::Say(String::from("Hello, world!")),
    Action::MoveTo(1, 2),
    Action::ChangeColorRGB(255, 255, 255),
  ];

  for action in actions {
    match action {
        Action::Say(s) => {
          println!("{}", s);
        }
        Action::MoveTo(x, y) => {
          println!("Moving to ({}, {})", x, y);
        }
        Action::ChangeColorRGB(r, g, b) => {
          println!("Changing color to RGB ({}, {}, {})", r, g, b);
        }
    }
  }
}
```

#### 穷尽匹配

在 `match` 匹配中需要将所有可能的值都进行匹配。但是有些情况下，我们可能并不关心所有可能的值，因此可以使用 `_` 来匹配所有可能的值，例如：

```rust
let some_u8_value = 0u8;

match some_u8_value {
    1 => println!("one"),
    3 => println!("three"),
    5 => println!("five"),
    7 => println!("seven"),
    _ => (),
}
```

通过将 `_` 其放置于其他分支后，`_` 将会匹配所有遗漏的值。() 表示返回单元类型与所有分支返回值的类型相同，所以当匹配到 `_` 后，什么也不会发生。
