---
title: match 控制结构
createTime: 2025/09/26 17:45:17
permalink: /rust/hpzb7ag9/
---

## 基本使用

控制运算符 `match` 允许将一个值与一系列的模式相比较，并根据匹配模式执行对应代码

> [!IMPORTANT]
> - `match` 后紧跟一个表达式，该达式返回值可以是任意类型，但需要与分支中的模式匹配
> - `match` 块内部就是模式与该模式的处理代码，**二者通过 `=>` 分开**
> - `match` 执行时会按顺序将表达式的值与每个分支中的模式进行比较，如果模式匹配，则执行对应分支中的代码，分支中代码的执行结果将作为整个表达式的返回值 

:::rust-repl title="match 的使用"
```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: &Coin) -> u8 {
    match coin {
      Coin::Penny =>  {
        println!("Lucky penny!");
        1
      },
      Coin::Nickel => 5,
      Coin::Dime => 10,
      Coin::Quarter => 25,
    }
}

fn main() {
    let penny = Coin::Penny;

    value_in_cents(&penny);
}
```
:::

### match 赋值语句

由于 `match` 本身也是一个表达式，因此可以在赋值语句中直接使用

:::rust-repl title="简写 match 赋值语句"
```rust
enum IpAddr {
   Ipv4,
   Ipv6
}

fn main() {
    let ip1 = IpAddr::Ipv6;
    let ip_str = match ip1 {
        IpAddr::Ipv4 => "127.0.0.1",
        _ => "::1",
    };

    println!("{}", ip_str);
}
```
:::

### 绑定值的模式

由于枚举的变体是可以携带数据的，因此还可以把匹配到的值绑定出来再去使用

:::rust-repl title="绑定值的模式"
```rust
enum Action {
  Say(String),
  MoveTo(i32, i32),
  ChangeColorRGB(u16, u16, u16),
}

fn main () {
  let actions = [
    Action::Say(String::from("Hello, world!")),
    Action::MoveTo(1, 2),
    Action::ChangeColorRGB(255, 255, 255),
  ];

  for action in actions {
    match action {
        Action::Say(s) => {
          println!("{}", s);
        }
        Action::MoveTo(x, y) => {
          println!("Moving to ({}, {})", x, y);
        }
        Action::ChangeColorRGB(r, g, b) => {
          println!("Changing color to RGB ({}, {}, {})", r, g, b);
        }
    }
  }
}
```
:::

### 匹配 `Option<T>`

当需要从 `Some` 中取值或处理 `None` 时，可直接对 `Option<T>` 进行 `match`

:::rust-repl title="Option 匹配取值或返回 None"
```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

fn main() {
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);

    println!("{six:?} {none:?}"); // Some(6) None
}
```
:::

> [!NOTE]
> - 本质上其实就是利用 `Option` 也是一个枚举，与正常的枚举使用是一样的
> - 与匹配其他枚举一样，`match` 必须覆盖 `Some` 和 `None` 两种变体，否则无法通过编译

### 穷尽匹配

在 `match` 匹配中需要将所有可能的值都进行匹配，否则将会报错。但在某些情况下并不需要处理所有可能的值，此时就可以使用占位符 `_` 来表示剩余可能的值

```rust
let some_u8_value = 0u8;

match some_u8_value {
    1 => println!("one"),
    3 => println!("three"),
    5 => println!("five"),
    7 => println!("seven"),
    _ => (),
}
```

> [!NOTE]
> `()` 表示返回单元类型与所有分支返回值的类型相同，所以当匹配到 `_` 后，什么也不会发生
