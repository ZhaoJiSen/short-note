---
title: 枚举与匹配模式
createTime: 2025/08/03 10:48:59
permalink: /rust/3j5m22g1/
---

## 枚举

枚举（enum）通过列可能的成员来定义一个==枚举类型==

```rust
enum PokerSuit {
    Clubs,
    Spades,
    Diamonds,
    Hearts,
}
```

### 枚举值
与其他语言不同的是，Rust 中的枚举可以存在==枚举值==，例如创建 `PokerSuit` 枚举类型的两个成员实例 `heart` 与 `diamond`

```rust
let heart = PokerSuit::Hearts;
let diamond = PokerSuit::Diamonds;
```

通过 `::` 操作符来访问 `PokerSuit` 枚举类型的成员，虽然 `heart` 与 `diamond` 是基于 `PokerSuit` 下的 `Hearts` 与 `Diamonds` 成员实例化的，但是它们全都属于 `PokerSuit` 枚举类型

```rust
fn print_suit(card: PokerSuit) {
  println!("Suit is {}", card);
}

fn main() {
  let heart = PokerSuit::Hearts;
  let diamond = PokerSuit::Diamonds;

  print_suit(heart);
  print_suit(diamond);
}
```

而上述所谓的 "枚举值" 指的是可以在枚举成员中添加值，然后直接将==数据信息关联到枚举成员中==，例如：

```rust
enum PokerSuit {
  Clubs(u8),
  Spades(u8),
  Diamonds(char),
  Hearts(char),
}

fn main() {
  let c1 = PokerSuit::Clubs(1);
  let c2 = PokerSuit::Diamonds('A');
}
```

### Option 枚举

在 Rust 中，没有其他语言中的 `null` 值，取而代之的是 `Option` 枚举类型。`Option` 枚举包含两个成员，一个成员表示含有：`Some(T)`，另一个成员表示不含有：`None`

```rust
enum Option<T> {
  Some(T),
  None,
}
```

::: tip 
`Option<T>` 枚举被包含在了 `prelude` 中，因此无需将其显示引用到文件中，其成员 `Some` 与 `None` 也是如此。
:::

如果使用 `None` 成员， 那么则需要显式地声明 `Option<T>` 的类型，编译器无法只通过 `None` 值来推断出 `Some` 成员的类型

```rust
let some_number = Some(5);
let some_char = Some('e');

// 显示声明
let absent_number: Option<i32> = None;
```

## 匹配模式

### match 匹配

`match` 匹配允许将一个值域一系列的模块相比较，并根据匹配模式执行对应代码。使用方式：

1. `match` 后紧跟一个表达式，该表达式返回值可以是任意类型，但需要与分支中的模式匹配。
2. `match` 分支由两部分组成：==模式与针对该模式的处理代码==，二者通过 `=>` 分开。
3. `match` 表达式执行时，会按顺序将表达式的值与每个分支中的模式进行比较，如果模式匹配，则执行对应分支中的代码，分支中代码的执行结果将作为整个 `match` 表达式的返回值。

```rust
enum Coin {
  Penny,
  Nickel,
  Dime,
  Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
  match coin {
    Coin::Penny =>  {
      println!("Lucky penny!");
      1
    },
    Coin::Nickel => 5,
    Coin::Dime => 10,
    Coin::Quarter => 25,
  }
}
```

::: details 
`match` 本身也是一个表达式，因此可以使用它进行赋值，例如：

```rust
enum IpAddr {
   Ipv4,
   Ipv6
}

fn main() {
    let ip1 = IpAddr::Ipv6;
    let ip_str = match ip1 {
        IpAddr::Ipv4 => "127.0.0.1",
        _ => "::1",
    };

    println!("{}", ip_str);
}
```
:::

#### 模式绑定

匹配模式的另外一个作用就是从模式中取出绑定的值

```rust
enum Action {
  Say(String),
  MoveTo(i32, i32),
  ChangeColorRGB(u16, u16, u16),
}

fn main () {
  let actions = [
    Action::Say(String::from("Hello, world!")),
    Action::MoveTo(1, 2),
    Action::ChangeColorRGB(255, 255, 255),
  ];

  for action in actions {
    match action {
        Action::Say(s) => {
          println!("{}", s);
        }
        Action::MoveTo(x, y) => {
          println!("Moving to ({}, {})", x, y);
        }
        Action::ChangeColorRGB(r, g, b) => {
          println!("Changing color to RGB ({}, {}, {})", r, g, b);
        }
    }
  }
}
```

#### 穷尽匹配

在 `match` 匹配中需要将所有可能的值都进行匹配。但是有些情况下，我们可能并不关心所有可能的值，因此可以使用 `_` 来匹配所有可能的值，例如：

```rust
let some_u8_value = 0u8;

match some_u8_value {
    1 => println!("one"),
    3 => println!("three"),
    5 => println!("five"),
    7 => println!("seven"),
    _ => (),
}
```

通过将 `_` 其放置于其他分支后，`_` 将会匹配所有遗漏的值。() 表示返回单元类型与所有分支返回值的类型相同，所以当匹配到 `_` 后，什么也不会发生。

### if let 匹配

有时会遇到只有==一个模式==的值需要被处理，其它值直接忽略的场景，那么此时就可以使用 `if let` 来处理

```rust
if let Some(3) = v {
    println!("three");
}
```

::: details 用 `match` 匹配的写法
```rust
let v = Some(3);

match v {
  Some(3) => println!("three"),
  _ => (),
}
```
:::

## matches! 宏

## 变量遮蔽
