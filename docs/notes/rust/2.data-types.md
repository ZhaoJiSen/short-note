---
title: 数据类型
createTime: 2025/07/26 14:13:13
permalink: /rust/kmvyux2l/
---

Rust 中每一个值都有其确切的数据类型，可分为两类：==基本类型==和==复合类型==。基本类型意味着它们往往是一个最小化的原子类，无法被解构为其他类型，而复合类型则由其他类型组合而成。

具体来说，基本类型由以下组成：
- 数值类型[+数值类型]
- 布尔类型：`true` 和 `false`
- 单元类型：即`()`，其唯一的值也是`()`
- 字符类型：表示单个 Unicode 字符，存储为 4 个字节

[+数值类型]:
  有符号整数：`i8`, `i16`, `i32`, `i64`, `i128`, `isize`
[+数值类型]:
  无符号整数：`u8`, `u16`, `u32`, `u64`, `u128`, `usize`
[+数值类型]:
  浮点数：`f32`, `f64`

## 类型推导与类型标注

与 JavaScript 等动态弱类型语言不通，Rust 是==静态强类型语言==，因此在编译时必须知道所有变量的类型。但这并不意味着需要指出每一个变量的类型，Rust 编译器会根据变量的值和上下文自动推导出变量的类型

## 数值类型

### 整数类型

整数是没有小数部分的数字。例如`i32`类型，表示有符号的 32 位整数（ `i` 是英文单词 integer 的首字母，与之相反的是 `u`，代表无符号 unsigned 类型）。无符号数表示数字只能取正数和 0，而有符号则表示数字可以取正数、负数还有 0

| 长度  | 有符号 | 无符号 |
|------|--------|--------|
| 8 位  | `i8`   | `u8`   |
| 16 位 | `i16`  | `u16`  |
| 32 位 | `i32`  | `u32`  |
| 64 位 | `i64`  | `u64`  |
| 128 位 | `i128`  | `u128`  |


::: tip 
`isize` 和 `usize` 类型取决于程序运行的计算机 CPU 类型： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位。
:::


::: info ==整型溢出==
所谓整型溢出指的是当一个数超过了其类型所能表示的范围时，会发生溢出。例如，`u8` 类型只能表示 0 到 255 之间的数字，如果给它赋值 256，就会发生溢出。

当 Rust 在 debug 模式编译时，会检查整型溢出，若存在溢出问题则直接 panic，而在 release 模式下，Rust 不会检测溢出，Rust 会按照补码循环溢出（two’s complement wrapping）的规则来进行处理。大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 u8 的情况下，256 变成 0，257 变成 1，依此类推。程序不会 panic，但是该变量的值可能不是你期望的值。依赖这种默认行为的代码都应该被认为是错误的代码。
:::

### 浮点类型

浮点类型数字 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： `f32` 和 `f64`，分别为 32 位和 64 位大小。默认浮点类型是 `f64`，在现代的 CPU 中它的速度与 `f32` 几乎相同，但精度更高。

### NaN

对于数学上未定义的结果，例如对负数取平方根 -42.1.sqrt() ，会产生一个特殊的结果：Rust 的浮点数类型使用 `NaN` (not a number) 来处理这些情况。


