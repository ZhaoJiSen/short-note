---
title: 微前端
tags:
  - 应用开发
createTime: 2026/02/27 15:07:01
permalink: /blog/u7yugjbj/
---

微前端可以理解为把前端单体应用拆成多个可独立开发、独立部署、独立运行的子应用，再由一个主应用在运行时把它们组合起来

:::table full-width

| 场景 | 单体应用痛点 | 微前端带来的改进 |
| --- | --- | --- |
| 多团队并行开发 | 代码耦合高，合并冲突多 | 按业务域拆分，团队边界清晰 |
| 发布频繁 | 一个模块改动需要整站发版 | 子应用独立发版，风险可控 |
| 技术栈演进 | 大版本升级成本高 | 允许渐进迁移，分批替换 |
| 系统整合 | 多系统入口分散 | 主应用统一入口和导航体验 |

:::

## 原理

[+JS隔离]: 避免全局变量污染
[+CSS隔离]: 避免样式串扰
[+路由隔离]: 子应用内部路由不影响其它应用

微前端本质是一套架构思路。核心议题是：一个页面如何安全地加载多个前端应用，并让它们在路由、样式、状态和依赖上协同工作

> [!IMPORTANT]
>
> 核心要点:
>
> - 按业务域拆分子应用，例如：`/order`、`/user`、`/analytics`。每个子应用有自己的仓库、发布节奏和技术栈
> - ==主应用根据当前 URL 或菜单状态决定 "该加载哪个子应用"==。这一步通常由路由分发 + 生命周期管理完成
> - 子应用通常暴露 `bootstrap`、`mount`、`unmount`。主应用只负责调度，不直接关心子应用内部实现细节
> - 通信机制采用事件总线、共享状态仓库、URL 参数、浏览器存储等
> - 对 React、Vue、lodash 这类公共依赖做共享，减少重复加载和版本冲突
> - 至少要做三类隔离，分别是 JS 隔离[+JS隔离]、CSS 隔离[+CSS隔离]、路由隔离[+路由隔离]

## 实现 mini 微前端

用原生 JS 实现一个最小可用版本：主应用根据路由在 `user-app` 和 `order-app` 之间切换，并逐步解决 JS 隔离、CSS 隔离、路由隔离等问题

### 目标能力

:::table full-width

| 触发方式 | 方案 |
| --- | --- |
| 输入 URL 回车、点击 `a` 标签 | 初始化时读取 `location.pathname`，并接管 `a` 默认跳转 |
| 子应用内部 `history` 跳转（Vue/React history） | 监听 `popstate`，并重写 `pushState/replaceState` 主动派发路由变更事件 |

:::

:::::steps

1. 先定义子应用协议（生命周期）

   先统一主应用和子应用之间的协议，后面不管子应用用 Vue、React 还是原生，都按这个协议接入。

   ```ts
   export interface MicroApp {
     name: string
     activeRule: (pathname: string) => boolean
     mount: (container: HTMLElement, ctx: AppContext) => void
     unmount: () => void
   }

   export interface AppContext {
     appName: string
     sandbox: Window
     effects: EffectScope
   }
   ```

2. 实现两个子应用（`user-app` / `order-app`）

   每个子应用都只暴露 `mount/unmount`，主应用只负责调度。

   :::code-tabs

   @tab apps/user-app.ts

   ```ts
   import type { MicroApp } from '../types'

   let root: HTMLDivElement | null = null

   export const userApp: MicroApp = {
     name: 'user-app',
     activeRule: pathname => pathname.startsWith('/user'),
     mount(container, ctx) {
       root = document.createElement('div')
       root.className = 'micro-app user-app'
       root.innerHTML = `
         <h2 class="title">User App</h2>
         <button id="to-order">跳到订单页</button>
       `

       container.innerHTML = ''
       container.appendChild(root)

       root.querySelector<HTMLButtonElement>('#to-order')?.addEventListener('click', () => {
         history.pushState({}, '', '/order')
       })

       // 故意挂一个全局变量，后续演示沙箱恢复
       ctx.sandbox.__MICRO_MARK__ = 'from-user-app'
     },
     unmount() {
       root?.remove()
       root = null
     },
   }
   ```

   @tab apps/order-app.ts

   ```ts
   import type { MicroApp } from '../types'

   let root: HTMLDivElement | null = null

   export const orderApp: MicroApp = {
     name: 'order-app',
     activeRule: pathname => pathname.startsWith('/order'),
     mount(container) {
       root = document.createElement('div')
       root.className = 'micro-app order-app'
       root.innerHTML = `
         <h2 class="title">Order App</h2>
         <button id="to-user">跳到用户页</button>
       `

       container.innerHTML = ''
       container.appendChild(root)

       root.querySelector<HTMLButtonElement>('#to-user')?.addEventListener('click', () => {
         history.pushState({}, '', '/user')
       })
     },
     unmount() {
       root?.remove()
       root = null
     },
   }
   ```

   :::

3. 主应用先支持“首次进入 + 前进后退”

   输入 URL 回车和浏览器前进后退本质上依赖 `pathname + popstate`。

   ```ts
   // main.ts
   import { userApp } from './apps/user-app'
   import { orderApp } from './apps/order-app'
   import type { MicroApp } from './types'

   const apps: MicroApp[] = [userApp, orderApp]
   const container = document.querySelector<HTMLElement>('#subapp-root')!
   let currentApp: MicroApp | null = null

   function reroute() {
     const pathname = location.pathname
     const targetApp = apps.find(app => app.activeRule(pathname)) || null

     if (currentApp && currentApp !== targetApp) {
       currentApp.unmount()
     }

     if (targetApp && currentApp !== targetApp) {
       targetApp.mount(container, createAppContext(targetApp.name))
     }

     currentApp = targetApp
   }

   window.addEventListener('popstate', reroute)
   reroute()
   ```

4. 补上 `pushState/replaceState` 劫持，解决子应用 history 跳转不触发问题

   这是 history 模式最容易漏的点：`pushState/replaceState` 默认不会触发 `popstate`。

   ```ts
   function patchHistoryEvent() {
     const rawPush = history.pushState
     const rawReplace = history.replaceState

     history.pushState = function (...args) {
       rawPush.apply(history, args as unknown as [data: any, unused: string, url?: string | URL | null])
       window.dispatchEvent(new Event('micro-route-change'))
     }

     history.replaceState = function (...args) {
       rawReplace.apply(history, args as unknown as [data: any, unused: string, url?: string | URL | null])
       window.dispatchEvent(new Event('micro-route-change'))
     }
   }

   patchHistoryEvent()
   window.addEventListener('micro-route-change', reroute)
   ```

5. 接管主应用导航（`a` 标签点击）

   防止整页刷新，让主应用路由调度始终接管跳转行为。

   ```ts
   document.querySelector('#main-nav')?.addEventListener('click', (e) => {
     const target = e.target as HTMLElement
     const link = target.closest('a[data-link]') as HTMLAnchorElement | null
     if (!link)
       return

     e.preventDefault()
     history.pushState({}, '', link.getAttribute('href')!)
   })
   ```

6. 修复缺陷 1：样式冲突

   第二张图第 1 点是“子应用同类名冲突”。最小方案是每个子应用强制根类名前缀。

   ```css
   /* user-app.css */
   .user-app .title {
     color: #1677ff;
   }

   /* order-app.css */
   .order-app .title {
     color: #13c2c2;
   }
   ```

7. 修复缺陷 2 + 3：全局变量冲突与 window 恢复（沙箱）

   第二张图第 2、3 点本质是“子应用污染全局”。最小可用做法是给每个子应用一个 `proxy sandbox`，并在卸载时恢复现场。

   ```ts
   // sandbox.ts
   export function createSandbox() {
     const fakeWindow = Object.create(null)
     const touchedKeys = new Set<PropertyKey>()
     const snapshot = new Map<PropertyKey, unknown>()

     const proxy = new Proxy(window, {
       get(target, key: PropertyKey) {
         if (key === 'window' || key === 'self' || key === 'globalThis')
           return proxy
         if (key in fakeWindow)
           return fakeWindow[key]
         return target[key as keyof Window]
       },
       set(target, key: PropertyKey, value) {
         if (!snapshot.has(key)) {
           snapshot.set(key, (target as any)[key])
         }
         touchedKeys.add(key)
         fakeWindow[key] = value
         return true
       },
     })

     function inactive() {
       for (const key of touchedKeys) {
         const oldValue = snapshot.get(key)
         if (oldValue === undefined) {
           delete (window as any)[key]
         }
         else {
           (window as any)[key] = oldValue
         }
       }

       touchedKeys.clear()
       Object.keys(fakeWindow).forEach(key => delete fakeWindow[key])
     }

     return { proxy: proxy as Window, inactive }
   }
   ```

8. 修复缺陷 4：全局监听/定时器泄漏（副作用托管）

   第二张图第 4 点是“子应用切换后副作用没卸载”。做法是主应用提供统一 `effects` 托管器，子应用只通过它注册副作用。

   ```ts
   export interface EffectScope {
     onWindow: (type: string, listener: EventListenerOrEventListenerObject) => void
     setInterval: (handler: TimerHandler, timeout?: number) => number
     setTimeout: (handler: TimerHandler, timeout?: number) => number
     clear: () => void
   }

   export function createEffectScope(): EffectScope {
     const cleanups: Array<() => void> = []

     return {
       onWindow(type, listener) {
         window.addEventListener(type, listener)
         cleanups.push(() => window.removeEventListener(type, listener))
       },
       setInterval(handler, timeout) {
         const id = window.setInterval(handler, timeout)
         cleanups.push(() => window.clearInterval(id))
         return id
       },
       setTimeout(handler, timeout) {
         const id = window.setTimeout(handler, timeout)
         cleanups.push(() => window.clearTimeout(id))
         return id
       },
       clear() {
         cleanups.splice(0).forEach(fn => fn())
       },
     }
   }
   ```

9. 把沙箱与副作用清理接入主应用切换流程

   这一步是整个 mini 方案能否稳定运行的关键：切应用时不仅要 `unmount`，还要做 `sandbox.inactive()` 和 `effects.clear()`。

   ```ts
   let currentSandbox: ReturnType<typeof createSandbox> | null = null
   let currentEffects: EffectScope | null = null

   function createAppContext(appName: string): AppContext {
     currentSandbox = createSandbox()
     currentEffects = createEffectScope()
     return {
       appName,
       sandbox: currentSandbox.proxy,
       effects: currentEffects,
     }
   }

   function unmountCurrentApp() {
     if (!currentApp)
       return
     currentApp.unmount()
     currentEffects?.clear()
     currentSandbox?.inactive()
     currentEffects = null
     currentSandbox = null
   }
   ```

:::::

### 关于沙箱环境

:::details 为什么需要沙箱

1. 防止子应用之间互相污染全局变量
2. 保证子应用切走后可以恢复 `window` 状态
3. 为多应用并存或快速切换提供隔离基础

:::

:::note 这个 mini 版本的边界

- `Proxy sandbox` 适合现代浏览器，不覆盖旧浏览器兼容层
- CSS 这里只做了最小隔离（根类名前缀），生产中建议配合 CSS Modules 或 Shadow DOM
- 如果子应用内部直接持有原始 `window` 引用（绕过 `ctx.sandbox`），仍可能造成泄漏

:::

## 微前端框架的使用

这里只保留 `qiankun` 方案。它补齐了常用能力，比如 JS 沙箱、样式隔离、预加载等，适合中后台与多子系统聚合场景。

:::code-tabs

@tab 主应用 main.ts

```ts
import { registerMicroApps, start } from 'qiankun'

registerMicroApps([
  {
    name: 'user-app',
    entry: '//localhost:7101',
    container: '#subapp-container',
    activeRule: '/user',
    props: { token: 'demo-token' },
  },
  {
    name: 'order-app',
    entry: '//localhost:7102',
    container: '#subapp-container',
    activeRule: '/order',
  },
])

start({
  sandbox: { strictStyleIsolation: false },
  prefetch: true,
})
```

@tab 子应用导出 lifecycle.ts

```ts
export async function bootstrap() {
  console.log('user app bootstrap')
}

export async function mount(props: Record<string, unknown>) {
  console.log('user app mount', props)
  // 在这里挂载 Vue/React 根组件
}

export async function unmount() {
  console.log('user app unmount')
  // 在这里卸载根组件并清理副作用
}
```

:::

## 落地时最容易忽略的点

:::details 生产环境检查清单

1. 是否有统一登录态方案（Cookie、Token 刷新、过期处理）
2. 是否有统一错误上报与链路追踪
3. 子应用静态资源是否支持灰度与快速回滚
4. 是否限制共享依赖版本，避免隐式升级
5. 卸载子应用时是否完整清理定时器、事件、全局对象

:::
