---
title: 策略模式
tags:
  - 设计模式
createTime: 2026/02/27 15:49:38
permalink: /blog/pvtqfjv9/
---

策略模式把可替换算法封装为独立策略对象，运行时按条件选择使用。

## 解决的问题

当一段业务存在大量 `if/else` 算法分支（如折扣、运费、支付）时，代码会臃肿且难扩展。

## 结构组成

:::table full-width

| 角色 | 作用 |
| --- | --- |
| Strategy | 策略抽象接口 |
| ConcreteStrategy | 各种策略实现 |
| Context | 选择并执行策略 |

:::

## 示例

```ts
interface ShippingStrategy {
  calc(weight: number): number
}

class NormalShipping implements ShippingStrategy {
  calc(weight: number) {
    return 8 + weight * 2
  }
}

class ExpressShipping implements ShippingStrategy {
  calc(weight: number) {
    return 15 + weight * 3
  }
}

class FreeShipping implements ShippingStrategy {
  calc() {
    return 0
  }
}

class ShippingContext {
  constructor(private strategy: ShippingStrategy) {}

  setStrategy(strategy: ShippingStrategy) {
    this.strategy = strategy
  }

  calc(weight: number) {
    return this.strategy.calc(weight)
  }
}

const context = new ShippingContext(new NormalShipping())
console.log(context.calc(2))

context.setStrategy(new ExpressShipping())
console.log(context.calc(2))

context.setStrategy(new FreeShipping())
console.log(context.calc(2))
```

## 适用场景

- 价格计算、推荐排序、风控规则
- 希望新增策略时不改旧逻辑

