---
title: 享元模式
tags:
  - 设计模式
createTime: 2026/02/27 15:49:14
permalink: /blog/swgybnna/
---

享元模式通过共享可复用的内部状态，减少大量相似对象的内存占用。

## 解决的问题

当系统需要创建很多“看起来不同但大部分数据相同”的对象时，内存和创建成本会很高。

## 结构组成

:::table full-width

| 角色 | 作用 |
| --- | --- |
| Flyweight | 共享对象（内部状态） |
| FlyweightFactory | 维护享元池 |
| Context | 外部状态（每次调用传入） |

:::

## 示例

```ts
class ChessPieceType {
  constructor(
    public readonly name: string,
    public readonly color: 'black' | 'white',
  ) {}
}

class ChessPieceFactory {
  private static pool = new Map<string, ChessPieceType>()

  static get(name: string, color: 'black' | 'white') {
    const key = `${name}-${color}`
    if (!this.pool.has(key)) {
      this.pool.set(key, new ChessPieceType(name, color))
    }
    return this.pool.get(key)!
  }

  static size() {
    return this.pool.size
  }
}

class ChessPiece {
  constructor(
    // 共享状态
    private readonly type: ChessPieceType,
    // 外部状态
    private x: number,
    private y: number,
  ) {}

  draw() {
    console.log(`${this.type.color} ${this.type.name} at (${this.x}, ${this.y})`)
  }
}

const p1 = new ChessPiece(ChessPieceFactory.get('pawn', 'white'), 1, 2)
const p2 = new ChessPiece(ChessPieceFactory.get('pawn', 'white'), 2, 2)
const p3 = new ChessPiece(ChessPieceFactory.get('pawn', 'black'), 1, 7)

p1.draw()
p2.draw()
p3.draw()
console.log('共享对象数量:', ChessPieceFactory.size()) // 2
```

## 适用场景

- 地图点位、棋子、字体字形等大量对象渲染
- 需要做对象池和缓存复用的场景

