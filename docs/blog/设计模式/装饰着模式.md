---
title: 装饰者模式
tags:
  - 设计模式
createTime: 2026/02/27 15:48:36
permalink: /blog/qoilq0ei/
---

装饰者模式通过“包裹对象”动态扩展能力，不改变原对象代码。

## 解决的问题

当功能需要可叠加（日志、缓存、重试、鉴权）时，继承会导致类爆炸，装饰者更灵活。

## 结构组成

:::table full-width

| 角色 | 作用 |
| --- | --- |
| Component | 统一接口 |
| ConcreteComponent | 原始对象 |
| Decorator | 包裹原始对象并增强行为 |

:::

## 示例

```ts
interface HttpClient {
  request(url: string): Promise<string>
}

class BaseClient implements HttpClient {
  async request(url: string) {
    return `response from ${url}`
  }
}

class LogDecorator implements HttpClient {
  constructor(private client: HttpClient) {}
  async request(url: string) {
    console.time(`request:${url}`)
    const res = await this.client.request(url)
    console.timeEnd(`request:${url}`)
    return res
  }
}

class RetryDecorator implements HttpClient {
  constructor(private client: HttpClient, private retries = 2) {}
  async request(url: string) {
    let lastErr: unknown
    for (let i = 0; i <= this.retries; i++) {
      try {
        return await this.client.request(url)
      }
      catch (err) {
        lastErr = err
      }
    }
    throw lastErr
  }
}

const client = new RetryDecorator(new LogDecorator(new BaseClient()), 3)
client.request('/api/user').then(console.log)
```

## 适用场景

- 请求链路增强（日志、重试、缓存）
- UI 组件能力叠加
- 不修改核心类前提下新增功能

