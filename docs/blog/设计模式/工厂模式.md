---
title: 工厂模式
tags:
  - 设计模式
createTime: 2026/02/27 15:47:34
permalink: /blog/x4bk31s2/
---

工厂模式的核心是把“对象创建”从业务代码中抽离，让调用方只依赖抽象，不依赖具体类名。

## 解决的问题

当对象创建逻辑复杂，或者未来存在多种实现切换需求时，把 `new Xxx()` 写在业务里会导致高耦合和大面积修改。

## 结构组成

:::table full-width

| 角色 | 作用 |
| --- | --- |
| Product（抽象产品） | 统一能力接口 |
| ConcreteProduct（具体产品） | 具体实现 |
| Factory（工厂） | 根据条件创建具体产品 |

:::

## 示例

```ts
interface Storage {
  set(key: string, value: string): void
  get(key: string): string | null
}

class LocalStorageImpl implements Storage {
  set(key: string, value: string) {
    localStorage.setItem(key, value)
  }
  get(key: string) {
    return localStorage.getItem(key)
  }
}

class MemoryStorageImpl implements Storage {
  private store = new Map<string, string>()
  set(key: string, value: string) {
    this.store.set(key, value)
  }
  get(key: string) {
    return this.store.get(key) ?? null
  }
}

type StorageType = 'local' | 'memory'

class StorageFactory {
  static create(type: StorageType): Storage {
    if (type === 'local')
      return new LocalStorageImpl()
    return new MemoryStorageImpl()
  }
}

// 业务层只依赖抽象 Storage，不关心具体实现
const storage = StorageFactory.create(import.meta.env.PROD ? 'local' : 'memory')
storage.set('token', 'abc123')
console.log(storage.get('token'))
```

## 适用场景

- 多实现切换：浏览器存储、日志上报、支付渠道
- 创建逻辑复杂：需要校验、默认值、依赖注入
- 需要隔离第三方 SDK 的实例化细节

