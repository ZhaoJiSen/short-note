---
title: 包装类与内置构造器
createTime: 2026/02/26 18:31:17
permalink: /javascript/0s0qdstf/
---

原始值（`number/string/boolean`）本身不是对象，但在访问属性或方法时，JavaScript 会临时把它“装箱”为对象，这就是包装类机制。

## 三大包装类

:::table
| 原始类型 | 对应包装类 |
| --- | --- |
| `number` | `Number` |
| `string` | `String` |
| `boolean` | `Boolean` |
:::

```js
console.log((123).toString()) // '123'
console.log('abc'.length) // 3
console.log(true.valueOf()) // true
```

## 自动装箱与拆箱

```js
let n = 1
n.len = 10

// 实际上类似：new Number(1).len = 10（临时对象）
// 临时对象没有被保存，表达式结束后即销毁
console.log(n.len) // undefined
```

## `null` / `undefined` 的特殊性

`null` 和 `undefined` 不参与装箱，直接访问属性会报错。

```js
// console.log(null.length) // TypeError
// console.log(undefined.length) // TypeError
```

## 包装对象参与运算

包装对象在运算时会先还原为原始值再计算。

```js
const boxed = new Number(1)
console.log(boxed + 1) // 2
```

## `new Boolean(false)` 的坑

`new Boolean(false)` 是对象，而对象在布尔上下文中永远是真值。

```js
if (new Boolean(false)) {
  console.log('会执行')
}
```

## Function 与 Object 的关系

`Function` 和 `Object` 是理解原型系统的重要入口。

```js
console.log(Object.__proto__ === Function.prototype) // true
console.log(Function.__proto__ === Function.prototype) // true
console.log(Function.prototype.__proto__ === Object.prototype) // true
```

:::note
可记忆为：
- 函数本质也是对象
- 构造器本质也是函数
- `Function` 既是构造器，也是它自己的实例链的一部分
:::
