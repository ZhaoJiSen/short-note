---
title: 代理与反射
createTime: 2026/02/26 10:46:57
permalink: /javascript/pm6r5fvv/
---

`Proxy` 与 `Reflect` 是 ES6 中一组配套能力：

1. `Proxy` 负责 "拦截"。  
2. `Reflect` 负责 "执行默认行为并返回标准结果"。

:::note 为什么需要 Proxy 与 Reflect

在很多业务里，不希望对象被直接读写，而是希望访问前后附带控制逻辑，例如：

1. 读取日志  
2. 写入校验  
3. 权限控制  
4. 虚拟字段

`Proxy` 让这些逻辑不必侵入原对象结构；`Reflect` 让代理内部调用默认行为时更标准、更可控。

:::

::::details 如下案例可以直观看到「直接对象访问」和「代理访问」的差异
:::code-tabs
@tab object.js

```js
const user = {
  name: 'Tom',
  price: 0
}

user.price = 1000
console.log(user.price) // 1000（没有任何校验）
```

@tab proxy.js

```js
const source = {
  name: 'Tom',
  price: 0
}

const user = new Proxy(source, {
  set(target, key, value, receiver) {
    if (key === 'price' && value < 100000) {
      throw new Error('报价过低')
    }

    return Reflect.set(target, key, value, receiver)
  }
})

user.price = 150000
console.log(user.price) // 150000
```
:::
::::

## 基本使用

`Proxy` 基本语法：

```js
const proxy = new Proxy(target, handler)
```

其中 `handler` 里的每个 trap 都是一个拦截器。

### Proxy 常用 API

:::table full-width

| Trap | 触发时机 | 常见用途 | 返回值要求 |
| --- | --- | --- | --- |
| `get` | 读取属性：`obj.foo` | 读取日志、字段兜底、权限控制 | 任意值 |
| `set` | 设置属性：`obj.foo = v` | 写入校验、脏数据拦截 | `boolean` |
| `has` | `key in obj` | 隐藏字段、权限判断 | `boolean` |
| `deleteProperty` | `delete obj.foo` | 阻止敏感字段被删 | `boolean` |
| `ownKeys` | `Object.keys / Reflect.ownKeys` | 控制可枚举键集合 | 键数组 |
| `apply` | 代理函数被调用 | 统一参数校验、埋点 | 任意值 |
| `construct` | 代理函数被 `new` 调用 | 构造过程增强 | 对象 |

:::

### Reflect 常用 API

:::table full-width

| API | 对应行为 | 说明 | 返回值 |
| --- | --- | --- | --- |
| `Reflect.get(target, key, receiver?)` | 读取属性 | 与代理 `get` 搭配最常见 | 属性值 |
| `Reflect.set(target, key, value, receiver?)` | 写入属性 | 成功与否返回布尔值 | `boolean` |
| `Reflect.has(target, key)` | `in` 判断 | 语义与 `in` 一致 | `boolean` |
| `Reflect.deleteProperty(target, key)` | 删除属性 | 删除成功与否可判断 | `boolean` |
| `Reflect.ownKeys(target)` | 取所有键 | 包括 `symbol` 键 | `Array<PropertyKey>` |
| `Reflect.apply(fn, thisArg, args)` | 函数调用 | 显式指定 `this` 与参数 | 任意值 |
| `Reflect.construct(Ctor, args)` | 构造调用 | 等价可控版 `new` | 对象 |

:::

### API 示例

:::code-tabs
@tab Proxy + Reflect（对象）

```js
const source = {
  name: 'Tom',
  phone: '13800000000',
  price: 0
}

const agent = new Proxy(source, {
  get(target, key, receiver) {
    if (key === 'phone') {
      return '请联系经纪人：400-888-8888'
    }

    return Reflect.get(target, key, receiver)
  },
  set(target, key, value, receiver) {
    if (key === 'price' && value < 100000) {
      throw new Error('报价过低')
    }

    return Reflect.set(target, key, value, receiver)
  }
})

agent.price = 150000
console.log(agent.phone)
console.log(agent.price)
```

@tab Proxy（函数）

```js
function sum(a, b) {
  return a + b
}

const wrapped = new Proxy(sum, {
  apply(target, thisArg, args) {
    console.log('调用参数:', args)
    return Reflect.apply(target, thisArg, args)
  }
})

console.log(wrapped(1, 2)) // 3
```
:::

## 演示：代理读写与校验

:::demo

```html
<!doctype html>
<html lang="zh-CN">
  <body>
    <pre id="out"></pre>

    <script>
      const source = {
        name: 'Tom',
        phone: '13800000000'
      }

      const agent = new Proxy(source, {
        get(target, key, receiver) {
          if (key === 'phone') {
            return '请联系经纪人：400-888-8888'
          }

          return Reflect.get(target, key, receiver)
        },
        set(target, key, value, receiver) {
          if (key === 'price' && value < 100000) {
            throw new Error('报价过低')
          }

          return Reflect.set(target, key, value, receiver)
        }
      })

      const out = []
      out.push('name => ' + agent.name)
      out.push('phone => ' + agent.phone)

      agent.price = 150000
      out.push('price => ' + agent.price)

      try {
        agent.price = 1000
      } catch (e) {
        out.push('低报价报错 => ' + e.message)
      }

      document.getElementById('out').textContent = out.join('\n')
    </script>
  </body>
</html>
```

:::

## 额外说明：`has` 与 `for...in`

`has` trap 拦截的是 `in` 操作符，并不会直接拦截 `for...in` 枚举。
如果要影响枚举结果，重点应放在 `ownKeys` 与属性描述符控制上。
