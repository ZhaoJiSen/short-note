---
title: 代理与反射
createTime: 2026/02/26 10:46:57
permalink: /javascript/pm6r5fvv/
---

`Proxy` 与 `Reflect` 是 ES6 中一组配套能力：

1. `Proxy` 负责“拦截”。
2. `Reflect` 负责“执行默认行为并返回标准结果”。

## 为什么需要 Proxy

很多场景里我们并不想直接暴露原对象，而是希望在访问前后插入控制逻辑，例如：

1. 读取日志。
2. 写入校验。
3. 权限控制。
4. 虚拟属性。

`Proxy` 可以在不改原对象结构的前提下完成这些能力。

## 基本语法

```js
const proxy = new Proxy(target, handler)
```

`handler` 中每个 trap 都是一个“拦截器”。

## 常用拦截器

:::table
| Trap | 触发时机 |
| --- | --- |
| `get` | 读取属性：`obj.foo` |
| `set` | 设置属性：`obj.foo = 1` |
| `has` | `in` 操作符 |
| `deleteProperty` | `delete obj.foo` |
| `ownKeys` | `Object.keys / Reflect.ownKeys` |
| `apply` | 代理函数被调用 |
| `construct` | 代理函数被 `new` 调用 |
:::

## 演示：代理读写与校验

:::demo
```html
<!doctype html>
<html lang="zh-CN">
  <body>
    <pre id="out"></pre>

    <script>
      const source = {
        name: 'Tom',
        phone: '13800000000'
      }

      const agent = new Proxy(source, {
        get(target, key, receiver) {
          if (key === 'phone') {
            return '请联系经纪人：400-888-8888'
          }

          return Reflect.get(target, key, receiver)
        },
        set(target, key, value, receiver) {
          if (key === 'price' && value < 100000) {
            throw new Error('报价过低')
          }

          return Reflect.set(target, key, value, receiver)
        }
      })

      const out = []
      out.push('name => ' + agent.name)
      out.push('phone => ' + agent.phone)

      agent.price = 150000
      out.push('price => ' + agent.price)

      try {
        agent.price = 1000
      } catch (e) {
        out.push('低报价报错 => ' + e.message)
      }

      document.getElementById('out').textContent = out.join('\n')
    </script>
  </body>
</html>
```
:::

## `Reflect` 的角色

`Reflect` 把许多对象内部操作变成了函数形式，
并提供统一返回值语义（如布尔成功态），更适合写在代理 trap 中。

:::code-tabs
@tab Reflect.get / set / has

```js
const user = { name: 'zs' }

console.log(Reflect.get(user, 'name')) // zs
Reflect.set(user, 'age', 18)
console.log(Reflect.has(user, 'age')) // true
```

@tab 与 Proxy 搭配

```js
const proxy = new Proxy(
  { count: 0 },
  {
    get(target, key, receiver) {
      console.log('read:', key)
      return Reflect.get(target, key, receiver)
    },
    set(target, key, value, receiver) {
      console.log('write:', key, value)
      return Reflect.set(target, key, value, receiver)
    }
  }
)

proxy.count += 1
```
:::

## 额外说明：`has` 与 `for...in`

`has` trap 拦截的是 `in` 操作符，
并不会直接拦截 `for...in` 的枚举流程。若要影响枚举结果，重点是 `ownKeys`。
