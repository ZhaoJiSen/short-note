---
title: 迭代器与生成器
createTime: 2026/02/26 18:59:27
permalink: /javascript/ykbm3k4m/
---

迭代器（Iterator）解决的是“按顺序取值”的问题，生成器（Generator）解决的是“如何方便地产生迭代器”的问题。

## 为什么需要迭代器

当数据结构不再是简单数组时（如 `Set`、`Map`、自定义对象），我们仍然希望统一地遍历它们。迭代器就是这层统一抽象。

:::table
| 概念 | 作用 | 关键点 |
| --- | --- | --- |
| 迭代器协议 | 规定“如何取下一个值” | 需要 `next()`，返回 `{ value, done }` |
| 可迭代协议 | 规定“如何拿到迭代器” | 需要实现 `Symbol.iterator()` |
:::

## 一个最小迭代器

```js
const arr = ['a', 'b', 'c']
let index = 0

const iterator = {
  next() {
    if (index < arr.length) {
      return { value: arr[index++], done: false }
    }
    return { value: undefined, done: true }
  },
}

console.log(iterator.next()) // { value: 'a', done: false }
console.log(iterator.next()) // { value: 'b', done: false }
console.log(iterator.next()) // { value: 'c', done: false }
console.log(iterator.next()) // { value: undefined, done: true }
```

## 让对象变成可迭代

只要实现 `Symbol.iterator`，对象就能被 `for...of`、展开运算符消费。

```js
const range = {
  start: 1,
  end: 3,
  [Symbol.iterator]() {
    let current = this.start
    const end = this.end

    return {
      next() {
        if (current <= end) {
          return { value: current++, done: false }
        }
        return { value: undefined, done: true }
      },
    }
  },
}

for (const n of range) {
  console.log(n) // 1 2 3
}

console.log([...range]) // [1, 2, 3]
```

## Generator：更自然地创建迭代器

`function*` 定义生成器函数，调用后不会立刻执行函数体，而是返回迭代器对象。

```js
function* gen() {
  yield 'A'
  yield 'B'
  return 'C'
}

const it = gen()
console.log(it.next()) // { value: 'A', done: false }
console.log(it.next()) // { value: 'B', done: false }
console.log(it.next()) // { value: 'C', done: true }
```

## `next(value)` 的回传机制

`yield` 既能产出值，也能接收下一次 `next` 传入的值。

```js
function* task() {
  const a = yield 1
  const b = yield a + 1
  return b + 1
}

const it = task()
console.log(it.next()) // { value: 1, done: false }
console.log(it.next(10)) // { value: 11, done: false }，a = 10
console.log(it.next(20)) // { value: 21, done: true }，b = 20
```

## 与 `async/await` 的关系

`async/await` 可以理解为“Generator + 自动执行器”的语法糖：

1. `await` 类似 `yield`，把控制权交出去。
2. 运行时会在 Promise 完成后自动恢复执行。
3. 你不需要手写 `next()` 调度逻辑。

下一章会用迭代器和生成器手写一个 `async/await` 版本。
