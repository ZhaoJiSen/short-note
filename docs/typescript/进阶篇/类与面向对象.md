---
title: 类与面向对象
createTime: 2026/02/09 21:38:00
permalink: /typescript/class-oop/
---

## 类成员与构造函数

```ts
class User {
  // 参数属性：自动声明并赋值
  constructor(
    public readonly id: string,
    public name: string,
    private password: string,
  ) {}

  rename(nextName: string) {
    this.name = nextName
  }
}
```

## 访问修饰符

- `public`：类内、实例、子类都可访问（默认）
- `private`：仅类内部可访问
- `protected`：类内部和子类可访问
- `readonly`：只读，不可二次赋值

## 静态成员

```ts
class Counter {
  static seed = 0
  id: number

  constructor() {
    this.id = ++Counter.seed
  }
}
```

静态成员属于类本身，不属于实例。

## 继承与 override

```ts
class Animal {
  move() {
    console.log('move')
  }
}

class Dog extends Animal {
  override move() {
    super.move()
    console.log('run')
  }
}
```

`override` 可以保证“确实在覆写父类成员”，防止拼写错误。

## implements 与抽象类

### implements 接口

```ts
interface Swimmable {
  swim: () => void
}

class Person implements Swimmable {
  swim() {
    console.log('swim')
  }
}
```

### 抽象类

抽象类用于定义“必须由子类完成”的契约。

```ts
abstract class Repository<T> {
  abstract findById(id: string): Promise<T | null>

  async mustFind(id: string): Promise<T> {
    const row = await this.findById(id)
    if (!row) throw new Error('Not found')
    return row
  }
}

class UserRepo extends Repository<{ id: string; name: string }> {
  async findById(id: string) {
    return { id, name: 'zjs' }
  }
}
```

> [!NOTE]
> 抽象类需要 `extends`，不是 `implements`。

## 类作为类型与构造签名

```ts
class Service {
  constructor(public name: string) {}
}

type ServiceCtor = new (name: string) => Service

function bootstrap(ctor: ServiceCtor) {
  return new ctor('api')
}
```
