---
title: 内置类型与类型断言
createTime: 2026/02/09 21:33:00
permalink: /typescript/builtin-and-assertion/
---

## `any`、`unknown`、`never`、`void`

### `any`

`any` 会跳过类型检查，等价于把这段代码降级回 JavaScript。

```ts
let data: any = 'hello'
data = 123
data.foo.bar() // 编译不报错，运行期可能直接崩
```

> [!WARNING]
> `any` 应该只在迁移期、第三方类型缺失等场景临时使用。

### `unknown`

`unknown` 是更安全的“任意类型”，使用前必须先缩小类型。

```ts
let value: unknown = JSON.parse('{"name":"zjs"}')

if (typeof value === 'object' && value !== null) {
  console.log('safe')
}
```

### `never`

`never` 表示“不会有值”。常见于：
- 永远抛错的函数
- 无限循环
- 穷尽性检查

```ts
function fail(msg: string): never {
  throw new Error(msg)
}

type Shape =
  | { kind: 'circle'; radius: number }
  | { kind: 'square'; size: number }

function area(shape: Shape) {
  switch (shape.kind) {
    case 'circle':
      return Math.PI * shape.radius * shape.radius
    case 'square':
      return shape.size * shape.size
    default: {
      const exhaustive: never = shape
      return exhaustive
    }
  }
}
```

### `void`

`void` 常用于函数返回值，表示“不关心返回值”。

```ts
function log(msg: string): void {
  console.log(msg)
}
```

## 类型断言

类型断言用于告诉编译器“我比你更清楚这个值的类型”。

```ts
const el = document.getElementById('avatar') as HTMLImageElement
el.src = '/avatar.png'
```

> [!WARNING]
> 断言不会做运行时校验，错误断言会把问题推迟到运行时。

## 非空断言 `!`

当你明确知道值不为 `null/undefined` 时可用非空断言。

```ts
function printUpper(input?: string) {
  console.log(input!.toUpperCase())
}
```

更推荐先做显式判断：

```ts
function printUpperSafe(input?: string) {
  if (!input) return
  console.log(input.toUpperCase())
}
```

## `as const` 与 `satisfies`

### `as const`

用于把对象/数组推导成只读字面量。

```ts
const config = {
  method: 'GET',
  retry: 3,
} as const
```

### `satisfies`

用于“校验结构，但不丢失推导精度”。

```ts
interface RequestConfig {
  method: 'GET' | 'POST'
  retry: number
}

const config = {
  method: 'GET',
  retry: 3,
} satisfies RequestConfig

// config.method 仍然是字面量 'GET'
```
