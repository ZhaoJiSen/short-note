---
title: 函数
createTime: 2026/02/09 21:35:00
permalink: /typescript/functions/
---

## 函数签名

```ts
function sum(a: number, b: number): number {
  return a + b
}
```

函数也可以先声明类型再实现：

```ts
type Sum = (a: number, b: number) => number

const sum: Sum = (a, b) => a + b
```

## 调用签名与构造签名

### 调用签名

用于描述“可调用对象”。

```ts
interface Counter {
  value: number
  (step: number): number
}

const counter = ((step: number) => {
  counter.value += step
  return counter.value
}) as Counter

counter.value = 0
```

### 构造签名

用于描述“可以被 `new` 的类型”。

```ts
class Person {
  constructor(public name: string) {}
}

type PersonCtor = new (name: string) => Person

function create(ctor: PersonCtor, name: string) {
  return new ctor(name)
}
```

## 参数系统

### 可选参数与默认参数

```ts
function greet(name: string, title?: string) {
  return title ? `${title} ${name}` : name
}

function greet2(name: string, title = 'Mr.') {
  return `${title} ${name}`
}
```

### Rest 参数

```ts
function total(...nums: number[]) {
  return nums.reduce((s, n) => s + n, 0)
}
```

## 函数重载

当“同名函数，不同参数，返回值也不同”时，用重载会更清晰。

```ts
function parse(input: string): number
function parse(input: number): string
function parse(input: string | number) {
  if (typeof input === 'string') {
    return Number(input)
  }
  return String(input)
}
```

> [!TIP]
> 能用联合类型就先用联合类型；只有返回值需要和入参强关联时再用重载。

## this 类型

在 `noImplicitThis` 开启时，可以显式声明 `this` 参数。

```ts
function print(this: { name: string }) {
  console.log(this.name)
}

print.call({ name: 'zjs' })
```

## this 相关工具类型

```ts
function foo(this: { token: string }, x: number) {
  return `${this.token}-${x}`
}

type FooThis = ThisParameterType<typeof foo>
type FooWithoutThis = OmitThisParameter<typeof foo>
```
