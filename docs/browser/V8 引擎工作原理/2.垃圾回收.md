---
title: 垃圾回收
createTime: 2026/02/26 12:50:09
permalink: /browser/iazznt48/
---

V8 的垃圾回收目标不是“清得最干净”，而是“在可接受停顿下维持吞吐”。

![GC 导图](/browser/source-images/1710902678608-88862067-22f7-46c9-8029-c066229f3331.jpeg)

## 栈内存回收：靠栈指针

函数执行结束后，栈指针回退，对应栈帧即变为无效区域，可被后续栈帧覆盖。

![栈回收示意](/browser/source-images/1710743823609-3c1ce39d-7355-492e-aeef-0e3712bc0b66.png)

## 堆内存回收：靠 GC

堆里的对象不会因为函数退出就自动释放，必须依赖 GC 判断“是否仍可达”。

![堆中残留对象](/browser/source-images/1710744303057-8ab08a0f-1da5-449e-9acc-bf0170578a8e.png)

## 代际假说与分代回收

V8 采用分代策略：

1. 新生代（Young Generation）：对象多、生命周期短、回收频繁。  
2. 老生代（Old Generation）：对象大/活得久，回收更谨慎。

![新生代与老生代](/browser/source-images/1710898167469-02a11cc1-99f0-4aec-90c0-cfb9ca4660b2.png)

## 新生代：Scavenge（复制算法）

新生代通常分为两个半区：使用区与空闲区。
GC 时把存活对象复制到另一半区，再交换角色。

优点：

- 回收快。  
- 顺便完成内存整理，几乎无碎片。

### 对象晋升

对象经过若干次新生代回收后仍存活，会晋升到老生代。

## 老生代：标记清除 + 标记整理

老生代主流程通常是：

1. 标记可达对象（Mark）。  
2. 清除不可达对象（Sweep）。  
3. 必要时整理内存碎片（Compact）。

![标记过程](/browser/source-images/1710898752800-c4ddce30-2d6b-4026-9b82-f252d2dba116.png)

![标记清除](/browser/source-images/1710898899539-be547823-e236-4b99-92c9-5b9e2a16b4f4.png)

![标记整理](/browser/source-images/1710899062125-97548967-bc20-42e1-aa25-1cd38bcba3c2.png)

## Stop-The-World 与增量标记

GC 发生时主线程可能暂停，这就是 `Stop-The-World`。

![全停顿](/browser/source-images/1710899750888-da316029-e41f-43a8-b15d-bb5b51774f8a.png)

为了减少长暂停，V8 对老生代引入增量标记，把大任务切成多个小片段，与 JS 执行交替进行。

![增量标记](/browser/source-images/1710899998668-4f05b287-a20f-4703-9097-6d6037311307.png)

## 线上排查建议

1. 优先看对象增长趋势，而不是单次内存峰值。  
2. 高频创建临时对象时，关注新生代 GC 频率。  
3. 页面卡顿伴随内存高波动时，检查老生代回收停顿。
