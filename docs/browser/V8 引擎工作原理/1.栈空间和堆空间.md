---
title: 栈空间和堆空间
createTime: 2026/02/26 12:49:52
permalink: /browser/5gybdts9/
---

理解 V8 的内存模型，最关键的一步是分清楚：

1. 执行上下文放在哪里。  
2. 对象数据放在哪里。  
3. 闭包为什么能“留住变量”。

![栈与堆导图](/browser/source-images/1710742733154-07a49937-9505-4ca3-b943-a5f4d2aa5f93.jpeg)

## 栈空间：执行上下文的工作区

栈（Call Stack）主要保存函数执行上下文。
函数调用入栈，执行结束出栈。

```js
function foo() {
  const a = 'hello'
  const b = a
  const c = { name: 'zs' }
  return c
}

foo()
```

![调用栈状态图](/browser/source-images/1710739743199-f1bbe273-176d-4c7f-b771-d9bd78ed597e.png)

## 堆空间：对象实体的存储区

对象、数组、函数对象等引用类型实体通常放在堆里，
栈里存的是“指向堆对象的引用”。

![对象存入堆空间](/browser/source-images/1710740104868-a4cbcb3c-ab27-48a5-bfa9-9bc74c054ece.png)

:::details 为什么不把所有数据都放栈里
栈要高频做上下文切换，追求的是“快进快出”。  
如果把大量对象都塞进栈，切换和回收成本会明显变高，执行效率会下降。
:::

## 闭包为什么不会立刻释放

闭包不是“神秘机制”，本质是：
内部函数仍然引用外部作用域变量，所以这些变量不能随外层函数退出而回收。

```js
function createCounter() {
  let count = 0

  return {
    inc() {
      count += 1
    },
    get() {
      return count
    }
  }
}

const counter = createCounter()
counter.inc()
console.log(counter.get()) // 1
```

![闭包内存示意](/browser/source-images/1710742199736-55cb457b-4e7a-4f99-b728-05712bfd96a7.png)

## 一个实用结论

当你在排查内存泄漏时，优先看两类对象：

1. 被长生命周期对象引用的短生命周期对象。  
2. 被闭包长期捕获但不再需要的数据。
