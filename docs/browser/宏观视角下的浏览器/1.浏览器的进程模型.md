---
title: 浏览器的进程模型
createTime: 2025/07/10 15:27:59
permalink: /browser/0pkbd4hl/
---

浏览器为什么要搞这么复杂的多进程架构？
核心原因不是“技术炫技”，而是要同时解决稳定性、性能和安全三件事。

## 进程与线程：先建立一个统一语义

- 进程：操作系统分配资源的基本单位，进程间默认隔离。
- 线程：CPU 调度的基本单位，线程依附于进程，线程间共享进程内存。

:::details 这组关系对浏览器很关键
1. 一个线程崩溃，可能拖垮整个进程。  
2. 线程共享内存，通信快，但更容易互相影响。  
3. 进程隔离强，崩溃可控，但通信要走 `IPC`。  
4. 浏览器大量任务（渲染、脚本、网络、输入）决定了它必须做线程和进程分工。
:::

![Chrome 架构导图](/browser/source-images/1709600493449-37980791-01ad-4b72-b677-7921545f952e.jpeg)

## 单进程浏览器的历史问题

早期浏览器把网络、渲染、脚本、插件基本都塞在一个进程里。

![单进程浏览器](/browser/source-images/6ddad2419b049b0eb2a8036f3dfff1ca.png)

:::steps
1. 不稳定：任意插件或页面脚本崩溃，整浏览器跟着崩。  
2. 不流畅：一个长任务（例如死循环）就能阻塞整个 UI。  
3. 不安全：插件和页面脚本在同一大上下文里，越权风险高。
:::

## Chrome 的多进程拆分思路

Chrome 的方向是“把高风险、高负载模块隔离到不同进程”。

![早期多进程](/browser/source-images/cdc9215e6c6377fc965b7fac8c3ec960.png)

![现代多进程](/browser/source-images/b61cab529fa31301bde290813b4587fc.png)

:::table
| 进程 | 主要职责 |
| --- | --- |
| Browser 主进程 | 地址栏、标签管理、前进后退、权限与存储、子进程调度 |
| Render 渲染进程 | HTML/CSS/JS 解析执行、布局绘制（沙箱内） |
| GPU 进程 | 合成与光栅化加速 |
| Network 进程 | DNS、连接、HTTP/HTTPS 请求调度 |
| 插件进程 | 插件独立运行，故障隔离 |
:::

![Chrome 任务管理器](/browser/source-images/1700209839880-cd692f18-bb0f-467d-b951-582e65a5a797.png)

## 为什么一个页面卡死时有时会“连坐”

默认“一个 Tab 一个渲染进程”只是近似描述。
Chrome 存在 `process-per-site-instance` 的复用策略：同站点页面可能复用同一个渲染进程。

这解释了你偶尔会看到“同站点多个页同时卡住/崩溃”。

:::details `same-site` 常见判断口径
协议 + 可注册域（及其子域）是关键因素。实践里可以先用“协议 + 主域”去理解，再结合浏览器隔离策略细节。
:::

## 面向服务化（SOA）趋势

Chrome 后续演进不是“继续加进程”，而是把能力拆成服务（Service），通过稳定接口通信。

![面向服务架构](/browser/source-images/1708929249602-7ae3c974-f3c9-4818-a5b3-01541e2a5306.png)

这种方式的价值是：

1. 单模块更容易迭代。  
2. 模块失败的影响面更可控。  
3. 在低端设备上还能按需合并服务，节省资源。
