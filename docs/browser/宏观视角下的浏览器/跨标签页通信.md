---
title: 跨标签页通信
createTime: 2025/11/12 21:50:59
permalink: /browser/69atp78u/
---

跨标签页通信的本质是：不同 `Browsing Context` 间共享状态和事件。
它不是只有一种方案，而是按“同源限制、实时性、复杂度”做取舍。

## 常见方案对比

:::table
| 方案 | 是否同源限制 | 是否实时 | 典型场景 |
| --- | --- | --- | --- |
| `BroadcastChannel` | 同源 | 高 | 多标签广播状态 |
| `storage` 事件 | 同源 | 中 | 简单同步（登录态变更） |
| `window.postMessage` | 可跨源（需显式校验） | 中 | 父子窗口/iframe 通信 |
| `SharedWorker` | 同源 | 高 | 多标签共享连接与内存状态 |
| `Service Worker` + `clients` | 同源 | 中高 | PWA 统一消息分发 |
:::

## 实用示例

:::code-tabs
@tab BroadcastChannel

```js
// tab-a / tab-b
const channel = new BroadcastChannel('app-sync')

channel.onmessage = (event) => {
  console.log('收到广播消息:', event.data)
}

function publishLogin(user) {
  channel.postMessage({ type: 'LOGIN', payload: user })
}
```

@tab localStorage + storage 事件

```js
// tab-a
localStorage.setItem(
  'app:event',
  JSON.stringify({ type: 'LOGOUT', at: Date.now() })
)

// tab-b
window.addEventListener('storage', (e) => {
  if (e.key !== 'app:event' || !e.newValue) return

  const payload = JSON.parse(e.newValue)
  console.log('收到 storage 变更:', payload)
})
```

@tab postMessage（父子窗口）

```js
// parent
const child = window.open('/child.html')
child?.postMessage({ type: 'PING' }, location.origin)

window.addEventListener('message', (event) => {
  if (event.origin !== location.origin) return
  console.log('父窗口收到:', event.data)
})

// child
window.addEventListener('message', (event) => {
  if (event.origin !== location.origin) return
  window.opener?.postMessage({ type: 'PONG' }, event.origin)
})
```
:::

## 选择建议

1. 同源多标签实时同步，优先 `BroadcastChannel`。  
2. 只做轻量状态同步，可用 `storage`。  
3. 涉及跨源窗口通信，使用 `postMessage`，并严格校验 `origin`。  
4. 需要“单连接多标签复用”（如 WebSocket 复用）时再考虑 `SharedWorker`。
