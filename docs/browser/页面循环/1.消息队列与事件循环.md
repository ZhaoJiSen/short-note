---
title: 消息队列与事件循环
createTime: 2026/02/26 12:50:39
permalink: /browser/iy6vaqnv/
---

浏览器渲染主线程是单线程，但它同时要做脚本执行、样式计算、布局、事件响应。
为了让这些任务可调度，浏览器引入了“事件循环 + 消息队列”模型。

![事件循环导图](/browser/source-images/1710984211726-b5c2e213-4e5a-4844-bd9e-a89300b26f84.jpeg)

## 为什么需要事件循环

如果只有“自上而下执行一次”的模型，就无法处理运行中动态到达的新任务（用户点击、网络返回、定时器到期）。

![单线程顺序执行](/browser/source-images/1711590034697-4bbfe7db-deeb-4a64-a030-5e026634bfef.png)

![引入循环处理新任务](/browser/source-images/1711590773582-f237cff6-ab65-4579-8a2f-8fccb34a0446.png)

## 消息队列负责什么

消息队列存放“待执行任务”，主线程每次循环取一个执行。
这就是典型的 FIFO（先进先出）语义。

![队列 + 循环](/browser/source-images/1711594590764-4b6cd869-3ab3-482a-b6b0-6f4263736c53.png)

:::details 线程与进程的任务怎么进队列
渲染进程内的 IO 线程会接收来自网络进程/浏览器进程的 IPC 消息，再把它们包装成任务投递到主线程队列。
:::

![跨进程消息投递](/browser/source-images/1711593611867-0f32cfa3-94b0-492e-9ca3-9987072eaa0d.png)

## 用代码理解循环骨架

```js
let running = true
const queue = []

function loop() {
  while (running) {
    const task = queue.shift()

    if (task) {
      task()
    }

    // 实际浏览器还会在合适时机执行渲染、输入事件分发等
  }
}
```

## 页面退出时为什么不会“永远转圈”

真实浏览器会维护退出标记。
当前任务结束后检查标记，若页面已销毁则停止事件循环并回收上下文。
