---
title: 跨域
createTime: 2026/02/27 00:26:47
permalink: /browser/o4w1ldgv/
---

[+SOP]: 同源策略（Same-Origin Policy），默认限制跨源读取。
[+CORS]: 跨源资源共享（Cross-Origin Resource Sharing），由服务端通过响应头授权。
[+Preflight]: 预检请求（OPTIONS），浏览器在“非简单请求”前自动发起，用于确认服务端是否允许。

::: card title="跨域学习地图" icon="material-icon-theme:console"
先记住一句话：==跨域本质是“浏览器安全边界 + 服务端授权”==。业务请求优先 `CORS/反向代理`，通信场景优先 `postMessage/WebSocket`，历史方案只用于理解兼容题。
:::

## 什么是跨域

跨域通常指浏览器环境下，页面源（协议 + 域名 + 端口）与目标资源源不一致时触发的安全限制。

- 同源策略[+SOP]默认拦截“跨源读取”能力。
- CORS[+CORS]不是绕过 SOP，而是服务端给浏览器的“放行白名单”。

:::tip
同源策略主要限制“读”，不一定限制“发”。例如表单可以跨站提交，但脚本通常不能直接读取跨站响应体。
:::

## 跨域方式总览

:::table full-width

| 方式 | 是否主流 | 适用场景 | 核心限制 |
| --- | --- | --- | --- |
| CORS | 是 | 前后端 API 请求 | 服务端必须正确返回 CORS 响应头 |
| 反向代理（Nginx/BFF） | 是 | 统一网关、生产环境 | 需要运维或网关层支持 |
| JSONP | 否（历史） | 只读公开 GET 接口 | 仅支持 GET，安全性弱 |
| postMessage | 是 | iframe / 多窗口通信 | 必须校验 `origin` |
| WebSocket | 是 | 实时通信 | 需处理鉴权、心跳、重连 |
| document.domain | 否（历史） | 同主域子域通信 | 仅限同主域，现代场景很少用 |
| window.name + iframe | 否（历史） | 老项目兼容 | 实现复杂，可维护性差 |
| location.hash + iframe | 否（历史） | 老项目兼容 | 仅适合小量消息传递 |
| 资源标签跨域（img/script/link） | 部分 | 资源加载/CDN | 通常可加载不可读返回细节 |

:::

## 1) CORS（主流标准方案）

### 原理

浏览器会根据请求类型决定是否先发预检[+Preflight]。服务端返回允许策略后，浏览器才把响应交给 JS。

:::warning
带 Cookie 的跨域请求必须同时满足：

1. 服务端返回精确 `Access-Control-Allow-Origin`（不能是 `*`）
2. 服务端返回 `Access-Control-Allow-Credentials: true`
3. 前端 `fetch(..., { credentials: 'include' })`
:::

### 完整案例（Node 服务端 + 浏览器前端）

:::code-tabs
@tab server.js

```js
// Node.js 原生 HTTP，演示 CORS 的核心响应头
import http from 'node:http'

const ALLOW_ORIGIN = 'http://localhost:5173'

const server = http.createServer((req, res) => {
  // 1) 允许的来源
  res.setHeader('Access-Control-Allow-Origin', ALLOW_ORIGIN)
  // 2) 允许携带凭证（Cookie）
  res.setHeader('Access-Control-Allow-Credentials', 'true')
  // 3) 允许的方法与头
  res.setHeader('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS')
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, X-CSRF-Token')
  // 4) 预检结果缓存时间（秒）
  res.setHeader('Access-Control-Max-Age', '600')

  // 预检请求直接返回 204
  if (req.method === 'OPTIONS') {
    res.writeHead(204)
    res.end()
    return
  }

  if (req.url === '/api/user' && req.method === 'GET') {
    res.writeHead(200, { 'Content-Type': 'application/json; charset=utf-8' })
    res.end(JSON.stringify({ code: 0, data: { id: 1, name: 'zhaojisen' } }))
    return
  }

  res.writeHead(404)
  res.end('Not Found')
})

server.listen(3000, () => {
  console.log('CORS API: http://localhost:3000')
})
```

@tab app.html

```html
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>CORS Demo</title>
  </head>
  <body>
    <button id="btn">请求跨域 API</button>
    <pre id="log"></pre>

    <script>
      const log = document.getElementById('log')
      document.getElementById('btn').addEventListener('click', async () => {
        try {
          const res = await fetch('http://localhost:3000/api/user', {
            method: 'GET',
            credentials: 'include', // 需要 cookie 时必须带上
            headers: {
              'X-CSRF-Token': 'demo-token',
            },
          })
          const data = await res.json()
          log.textContent = JSON.stringify(data, null, 2)
        } catch (err) {
          log.textContent = String(err)
        }
      })
    </script>
  </body>
</html>
```
:::

## 2) 反向代理（生产高频）

前端访问同源 `/api`，由 Nginx 或 BFF 转发到真实后端，这样浏览器视角就不是跨域。

:::code-tabs
@tab nginx.conf

```nginx
server {
  listen 80;
  server_name demo.local;

  # 前端静态资源
  location / {
    root /var/www/app;
    try_files $uri /index.html;
  }

  # 关键：同源 /api 代理到真实后端
  location /api/ {
    proxy_pass http://127.0.0.1:3000/;
    proxy_http_version 1.1;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  }
}
```

@tab 前端调用

```js
// 浏览器只看到同源 /api，不触发 CORS
const res = await fetch('/api/user')
const data = await res.json()
console.log(data)
```
:::

::::details 为什么很多公司线上更偏向“代理 + 网关”

1. 安全策略集中在网关，减少每个服务重复配置 CORS。
2. 便于统一鉴权、限流、日志追踪。
3. 前端调用地址稳定，不暴露内部服务拓扑。

::::

## 3) JSONP（历史方案，仅 GET）

JSONP 利用 `<script>` 不受 XHR 同源限制：服务端返回“可执行 JS”，前端通过全局回调拿数据。

:::warning
JSONP 只能 GET，且有脚本注入风险，现代业务一般不推荐。
:::

:::code-tabs
@tab server.js

```js
import http from 'node:http'

const server = http.createServer((req, res) => {
  const url = new URL(req.url, 'http://localhost:3000')
  if (url.pathname !== '/jsonp') {
    res.writeHead(404)
    res.end('Not Found')
    return
  }

  const callback = url.searchParams.get('callback') || 'cb'
  const payload = { code: 0, data: { name: 'jsonp-user' } }

  res.writeHead(200, { 'Content-Type': 'application/javascript; charset=utf-8' })
  // 返回可执行 JS：调用前端定义的全局函数
  res.end(`${callback}(${JSON.stringify(payload)})`)
})

server.listen(3000)
```

@tab client.html

```html
<!doctype html>
<html lang="zh-CN">
  <body>
    <pre id="log"></pre>

    <script>
      function handleJsonp(data) {
        document.getElementById('log').textContent = JSON.stringify(data, null, 2)
      }

      const script = document.createElement('script')
      script.src = 'http://localhost:3000/jsonp?callback=handleJsonp'
      document.body.appendChild(script)
    </script>
  </body>
</html>
```
:::

## 4) postMessage（iframe / 多窗口通信）

适合窗口间通信，不是用来直接请求后端 API。

:::code-tabs
@tab parent.html

```html
<!doctype html>
<html lang="zh-CN">
  <body>
    <iframe id="child" src="http://localhost:4000/child.html"></iframe>
    <script>
      const frame = document.getElementById('child')

      // 发送消息给子窗口
      frame.onload = () => {
        frame.contentWindow.postMessage(
          { type: 'PING', payload: 'hello child' },
          'http://localhost:4000', // 必须写目标源，避免 *
        )
      }

      // 接收子窗口消息
      window.addEventListener('message', (event) => {
        if (event.origin !== 'http://localhost:4000') return // 核心安全校验
        console.log('from child:', event.data)
      })
    </script>
  </body>
</html>
```

@tab child.html

```html
<!doctype html>
<html lang="zh-CN">
  <body>
    <script>
      window.addEventListener('message', (event) => {
        if (event.origin !== 'http://localhost:3000') return

        // 回消息给父窗口
        event.source.postMessage(
          { type: 'PONG', payload: `recv: ${event.data.payload}` },
          event.origin,
        )
      })
    </script>
  </body>
</html>
```
:::

## 5) WebSocket（跨源实时通信）

WebSocket 建连时仍有 Origin 概念，但规则不走 CORS 那套 `Access-Control-*`。

:::code-tabs
@tab server.js（ws）

```js
import { WebSocketServer } from 'ws'

const wss = new WebSocketServer({ port: 3001 })

wss.on('connection', (socket, req) => {
  // 跨源校验重点看 Origin
  const origin = req.headers.origin || ''
  if (origin !== 'http://localhost:5173') {
    socket.close(1008, 'origin not allowed')
    return
  }

  socket.on('message', (data) => {
    // 回显消息
    socket.send(`echo: ${data}`)
  })
})
```

@tab browser.js

```js
const ws = new WebSocket('ws://localhost:3001')

ws.onopen = () => {
  ws.send('hello')
}

ws.onmessage = (event) => {
  console.log(event.data)
}
```
:::

## 6) document.domain（历史方案）

仅适用于同主域子域（如 `a.example.com` 与 `b.example.com`）。

:::code-tabs
@tab a.example.com/a.html

```html
<script>
  // 两端都降到主域
  document.domain = 'example.com'

  function readChild() {
    const iframe = document.getElementById('f')
    // 现在可访问同主域子页面 DOM
    console.log(iframe.contentWindow.document.body.innerText)
  }
</script>
<iframe id="f" src="http://b.example.com/b.html"></iframe>
<button onclick="readChild()">读取子页面</button>
```

@tab b.example.com/b.html

```html
<script>
  document.domain = 'example.com'
</script>
<div>hello from b.example.com</div>
```
:::

## 7) window.name + iframe（历史兼容）

`window.name` 在一次页面跳转后仍保留，可用于跨域“中转读取”。

:::code-tabs
@tab 目标页（cross.com/data.html）

```html
<script>
  // 跨域页面先把数据放进 window.name
  window.name = JSON.stringify({ code: 0, data: ['A', 'B', 'C'] })
  // 再跳到与父页面同源的中转页
  location.href = 'http://app.com/proxy.html'
</script>
```

@tab 父页（app.com/index.html）

```html
<iframe id="f" src="http://cross.com/data.html" style="display:none"></iframe>
<script>
  const iframe = document.getElementById('f')
  iframe.onload = () => {
    // 第二次 onload 时，iframe 已跳到同源 proxy.html
    // 此时父页面可读取 iframe.contentWindow.name
    const text = iframe.contentWindow.name
    const data = JSON.parse(text)
    console.log(data)
  }
</script>
```

@tab 中转页（app.com/proxy.html）

```html
<!-- 空白页即可，关键是与父页面同源 -->
```
:::

## 8) location.hash + iframe（历史兼容）

通过 URL hash 传值，再由中转页回传。

:::code-tabs
@tab 父页（a.com/index.html）

```html
<iframe id="f" src="http://b.com/child.html#name=zhaojisen"></iframe>
<script>
  window.addEventListener('hashchange', () => {
    // 读取代理页回传的 hash
    console.log('recv:', location.hash)
  })
</script>
```

@tab 子页（b.com/child.html）

```html
<script>
  // 读取父页给的 hash
  const payload = location.hash.slice(1)
  // 跳到父页同源代理页并带上数据
  location.href = `http://a.com/proxy.html#${payload}`
</script>
```

@tab 代理页（a.com/proxy.html）

```html
<script>
  // 同源下可操作 parent，把 hash 回传给父页面
  parent.location.hash = location.hash.slice(1)
</script>
```
:::

## 9) 资源标签跨域加载（可加载，不等于可读）

`img/script/link/iframe` 可跨域加载资源，但对响应数据可读性有边界。

:::code-tabs
@tab 示例

```html
<!-- 可跨域加载图片 -->
<img src="https://cdn.example.com/logo.png" alt="logo" />

<!-- 可跨域加载脚本（脚本有执行风险） -->
<script src="https://cdn.example.com/app.js"></script>

<!-- 可跨域加载样式 -->
<link rel="stylesheet" href="https://cdn.example.com/app.css" />
```

@tab Canvas 污染提醒

```js
const img = new Image()
img.src = 'https://cdn.example.com/a.png'
img.onload = () => {
  const canvas = document.createElement('canvas')
  const ctx = canvas.getContext('2d')
  ctx.drawImage(img, 0, 0)

  // 跨域图片未配置 CORS 时，这里会抛异常（污染画布）
  console.log(canvas.toDataURL())
}
```
:::

## 面试速记

::::details 高频追问（建议背诵）

1. CORS 是什么？
   CORS 是浏览器跨源授权机制，不是绕过同源策略。
2. 为什么会有预检？
   为了在真正发起“可能有副作用”的请求前先协商权限。
3. 为什么 `Access-Control-Allow-Origin` 不能和凭证一起用 `*`？
   因为携带身份信息时必须精确控制可访问来源。

::::

:::::collapse
- :+ 选型建议（业务实战）

  1. 前后端 API：优先 `CORS` 或 `反向代理`。
  2. 页面间通信：优先 `postMessage`。
  3. 实时通信：优先 `WebSocket`（配合鉴权 + 心跳 + 重连）。
  4. `JSONP / document.domain / window.name / hash` 作为历史兼容知识即可。
::::

:::demo
```html
<!doctype html>
<html lang="zh-CN">
  <body>
    <button id="btn">发送 postMessage</button>
    <pre id="log"></pre>
    <iframe id="frame" srcdoc="<script>window.onmessage=(e)=>e.source.postMessage('child-recv:'+e.data,e.origin)<\/script>"></iframe>

    <script>
      const btn = document.getElementById('btn')
      const frame = document.getElementById('frame')
      const log = document.getElementById('log')

      btn.onclick = () => {
        frame.contentWindow.postMessage('hello', location.origin)
      }

      window.onmessage = (e) => {
        if (e.origin !== location.origin) return
        log.textContent = e.data
      }
    </script>
  </body>
</html>
```
:::
