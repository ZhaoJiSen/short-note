---
title: 实现 SSR
createTime: 2026/01/21 16:29:28
permalink: /vue/ts199xd9/
---

[+激活模式]: 客户端加载后执行注入的脚本，接管服务端渲染出的 HTML（hydration）
[+应用]: 这里应用指的是 SSR 服务器代码（Node 进程 + bundle）被加载一次

## 文件结构

整体的文件结构如下：

::: file-tree

- dist 打包后生成的目录
  - client
    - client_bundle.js
  - server_bundle.js
- frontend
  - entry-client.js
  - App.vue
  - main.js
- src
  - index.js
- package.json
- webpack.server.config.js
- webpack.client.config.js
- pnpm-lock.yaml
- .gitignore
  :::

## 实现步骤

::::steps

1. 安装相关依赖及文件配置

   ```bash
   pnpm add express
   pnpm add vue-router
   pnpm add pinia
   pnpm add @vue/server-renderer

   pnpm add nodemon -D
   pnpm add webpack-merge -D
   pnpm add pino-pretty pino -D
   pnpm add vue vue-loader babel-loader @babel/preset-env -D
   pnpm add webpack webpack-cli webpack-node-externals -D
   ```

   这里创建两套 webpack 配置用于分别打包 Node 与 Vue 代码
   :::code-tabs
   @tab webpack.server.config.js

   ```js
   const { resolve } = require('path');
   const nodeExternals = require('webpack-node-externals');
   const { VueLoaderPlugin } = require('vue-loader');

   /** @type {import('webpack').Configuration} */
   module.exports = {
     target: 'node',
     mode: 'development',
     entry: './src/index.js',
     output: {
       filename: 'server_bundle.js',
       path: resolve(__dirname, './dist'),
     },
     externals: [nodeExternals()],
     module: {
       rules: [
         {
           test: /\.js$/,
           loader: 'babel-loader',
           options: {
             presets: ['@babel/preset-env'],
           },
         },
         {
           test: /\.vue$/,
           loader: 'vue-loader',
         },
       ],
     },
     resolve: {
       extensions: ['.js', '.vue', '.ts'],
     },
     plugins: [new VueLoaderPlugin()],
   };
   ```

   @tab webpack.client.config.js

   ```js
   const { resolve } = require('path');
   const { VueLoaderPlugin } = require('vue-loader');

   module.exports = {
     mode: 'development',
     target: 'web',
     entry: './frontend/entry-client.js',
     output: {
       filename: 'client_bundle.js',
       path: resolve(__dirname, 'dist/client'),
       publicPath: '/client/',
     },
     module: {
       rules: [
         { test: /\.vue$/, loader: 'vue-loader' },
         { test: /\.js$/, exclude: /node_modules/, use: 'babel-loader' },
       ],
     },
     resolve: { extensions: ['.js', '.vue'] },
     plugins: [new VueLoaderPlugin()],
   };
   ```

   @tab package.json

   ```json
   {
     "scripts": {
       "dev": "nodemon src/index.js | pino-pretty",
       "build:server": "webpack --config webpack.server.config.js --watch",
       "build:client": "webpack --config webpack.client.config.js --watch",
       "preview": "nodemon ./dist/server_bundle.js | pino-pretty"
     },
     "dependencies": {
       "@vue/server-renderer": "^3.5.27",
       "express": "^5.2.1",
       "pino": "^10.2.1"
     },
     "devDependencies": {
       "@babel/preset-env": "^7.28.6",
       "babel-loader": "^10.0.0",
       "nodemon": "^3.1.11",
       "pino-pretty": "^13.1.3",
       "vue": "^3.5.27",
       "vue-loader": "^17.4.2",
       "webpack": "^5.104.1",
       "webpack-cli": "^6.0.1",
       "webpack-merge": "^6.0.1",
       "webpack-node-externals": "^3.0.0"
     }
   }
   ```

   @tab

   :::

2. 对外暴露 createApp

   在 Vue 的 SSR 场景中，需要通过 `createSSRApp` 创建应用实例，然后向外暴露函数 `createApp`，服务端就可以通过该方法获取应用实例，再通过`renderToString` 将其渲染为 HTML

   > [!NOTE]
   > 在客户端入口里调用 `createApp` 并执行 `app.mount('#app')` 时，Vue 会复用已有 DOM，并接管事件监听与响应式能力（即 hydration）

   :::code-tabs
   @tab main.js

   ```js
   import { createSSRApp } from 'vue';
   import App from './App.vue';

   export default function createApp() {
     const app = createSSRApp(App);
     return { app };
   }
   ```

   @tab entry-client.js

   ```js
   import createApp from './main';

   const { app } = createApp();
   app.mount('#app');
   ```

   @tab App.vue

   ```vue
   <template>
     <div>
       <h2>Vue</h2>
       <div>{{ counter }}</div>
       <button @click="plus"></button>
     </div>
   </template>

   <script setup>
   import { ref } from 'vue';

   const counter = ref(0);

   const plus = () => {
     counter.value++;
   };
   </script>
   ```

   :::

   > [!IMPORTANT]
   > 在 Vue 的 SPA 中，用户每次打开页面都会重新创建一个 App 对象实例、Router 实例、Store 实例等等，因此每个对象实例的状态并不会被污染
   >
   > 而在 SSR 应用中，应用[+应用]通常只在服务器启动时初始化一次，如果直接复用同一个实例去处理所有请求，请求之间就会共享状态就会导致 "夸请求状态污染" 的问题。所以为了避免这个问题，我们将   `createApp` 写成工厂函数，每个请求调用一次，返回一组全新的 App/Router/Store 实例，这样状态就被隔离了

3. 从 Vue 到字符串 HTML

   在服务端通过调用 `@vue/server-renderer` 提供的 `renderToString` 方法把应用实例渲染为 HTML 字符串

   :::code-tabs
   @tab src/index.js

   ```js
   const pino = require('pino');
   const express = require('express');
   const createApp = require('../frontend/main').default;

   const { resolve } = require('path');
   const { renderToString } = require('@vue/server-renderer');

   const app = express();
   const logger = pino();

   app.get('/', async (req, res) => {
     let { app: vueApp } = createApp();
     let appString = await renderToString(vueApp);

     res.send(
       `
       <!DOCTYPE html>
       <html lang="en">
       <head>
         <meta charset="UTF-8">
         <meta name="viewport" content="width=device-width, initial-scale=1.0">
         <title>Document</title>
       </head>
       <body>
         <div id="app">${appString}</div>
       </body>
       </html>
       `,
     );
   });

   app.listen(9999, () => {
     logger.info('Server is running at http://localhost:9999');
   });
   ```

   :::

   此时渲染的内容并不可交互，因为此时还没有进入到激活模式[+激活模式]，因此接下来要做的是让 HTML 变得可交互，这一步就是 Hydration

4. Hydration

   Hydration 通过在服务端渲染的 HTML 中引入客户端 bundle 来完成。==客户端 bundle 执行后会触发应用的挂载流程，在复用现有 DOM 结构的前提下，为页面补充事件监听和响应式逻辑，使其从 "静态 HTML" 转变为可交互的应用==

   :::code-tabs
   @tab src/index.js

   ```js
   const pino = require('pino');
   const express = require('express');
   const createApp = require('../frontend/main').default;

   const { resolve } = require('path');
   const { renderToString } = require('@vue/server-renderer');

   const app = express();
   const logger = pino();

   app.use('/client', express.static(resolve(__dirname, '../dist/client'))); // [!code ++]

   app.get('/', async (req, res) => {
     let { app: vueApp } = createApp();
     let appString = await renderToString(vueApp);

     res.send(
       [
         '<!DOCTYPE html>',
         '<body>',
         '<div id="app">' + appString + '</div>',
         '<script src="/client/client_bundle.js"></script>', // [!code ++]
         '</body>',
       ].join('\n'),
     );
   });

   app.listen(9999, () => {
     logger.info('Server is running at http://localhost:9999');
   });
   ```

   :::

   :::note
   不稳定的数据源，例如 `Math.random()`、`Date.now()` 等依赖浏览器 API 的逻辑、以及请求间共享状态，都会导致服务端与客户端渲染结果不一致进而导致 hydration mismatch

   **解决方式是把这些逻辑放到客户端挂载后执行，或用环境判断隔离**
   :::

5. 路由的实现
   


6. Store 的实现

7. 优化 Webpack 配置
::::

