---
title: 实现 SSR
createTime: 2026/01/21 16:29:28
permalink: /vue/ts199xd9/
---

[+激活模式]: 客户端加载后执行注入的脚本，接管服务端渲染出的 HTML（hydration）

整体的文件结构

::: file-tree

- dist 打包后生成的目录
  - client
    - client_bundle.js
  - server_bundle.js
- frontend
  - entry-client.js
  - App.vue
  - main.js
- src
  - index.js
- package.json
- webpack.server.config.js
- webpack.client.config.js
- pnpm-lock.yaml
- .gitignore
  :::

::::steps

1. 安装相关依赖及文件配置

   安装依赖（服务端运行、日志输出与 Node 端打包）

   ```bash
   pnpm add express
   pnpm add @vue/server-renderer

   pnpm add nodemon -D
   pnpm add webpack-merge -D
   pnpm add pino-pretty pino -D
   pnpm add vue vue-loader babel-loader @babel/preset-env -D
   pnpm add webpack webpack-cli webpack-node-externals -D
   ```

   这里创建两套 webpack 配置用于分别打包 Node 与 Vue 代码
   :::code-tabs
   @tab webpack.server.config.js

   ```js
   const { resolve } = require('path');
   const nodeExternals = require('webpack-node-externals');
   const { VueLoaderPlugin } = require('vue-loader');

   /** @type {import('webpack').Configuration} */
   module.exports = {
     target: 'node',
     mode: 'development',
     entry: './src/index.js',
     output: {
       filename: 'server_bundle.js',
       path: resolve(__dirname, './dist'),
     },
     externals: [nodeExternals()],
     module: {
       rules: [
         {
           test: /\.js$/,
           loader: 'babel-loader',
           options: {
             presets: ['@babel/preset-env'],
           },
         },
         {
           test: /\.vue$/,
           loader: 'vue-loader',
         },
       ],
     },
     resolve: {
       extensions: ['.js', '.vue', '.ts'],
     },
     plugins: [new VueLoaderPlugin()],
   };
   ```

   @tab webpack.client.config.js

   ```js
   const { resolve } = require('path');
   const { VueLoaderPlugin } = require('vue-loader');

   module.exports = {
     mode: 'development',
     target: 'web',
     entry: './frontend/entry-client.js',
     output: {
       filename: 'client_bundle.js',
       path: resolve(__dirname, 'dist/client'),
       publicPath: '/client/',
     },
     module: {
       rules: [
         { test: /\.vue$/, loader: 'vue-loader' },
         { test: /\.js$/, exclude: /node_modules/, use: 'babel-loader' },
       ],
     },
     resolve: { extensions: ['.js', '.vue'] },
     plugins: [new VueLoaderPlugin()],
   };
   ```

   @tab package.json

   ```json
   {
     "scripts": {
       "dev": "nodemon src/index.js | pino-pretty",
       "build:server": "webpack --config webpack.server.config.js --watch",
       "build:client": "webpack --config webpack.client.config.js --watch",
       "preview": "nodemon ./dist/server_bundle.js | pino-pretty"
     },
     "dependencies": {
       "@vue/server-renderer": "^3.5.27",
       "express": "^5.2.1",
       "pino": "^10.2.1"
     },
     "devDependencies": {
       "@babel/preset-env": "^7.28.6",
       "babel-loader": "^10.0.0",
       "nodemon": "^3.1.11",
       "pino-pretty": "^13.1.3",
       "vue": "^3.5.27",
       "vue-loader": "^17.4.2",
       "webpack": "^5.104.1",
       "webpack-cli": "^6.0.1",
       "webpack-merge": "^6.0.1",
       "webpack-node-externals": "^3.0.0"
     }
   }
   ```

   @tab

   :::

2. 对外暴露 createApp

   在 Vue 的 SSR 场景中，需要通过 `createSSRApp` 创建应用实例

   客户端入口对外暴露 `createApp` 方法，Node 端调用该方法获取应用实例，并通过 `renderToString` 将其渲染为 HTML

   在客户端入口里调用 `createApp` 并 `app.mount('#app')`，Vue 会复用已有 DOM，把事件监听与响应式能力接管到页面上

   :::code-tabs
   @tab main.js

   ```js
   import { createSSRApp } from 'vue';
   import App from './App.vue';

   export default function createApp() {
     const app = createSSRApp(App);
     return { app };
   }
   ```

   @tab entry-client.js

   ```js
   import createApp from './main';

   const { app } = createApp();
   app.mount('#app');
   ```

   @tab App.vue

   ```vue
   <template>
     <div>
       <h2>Vue</h2>
       <div>{{ counter }}</div>
       <button @click="plus"></button>
     </div>
   </template>

   <script setup>
   import { ref } from 'vue';

   const counter = ref(0);

   const plus = () => {
     counter.value++;
   };
   </script>
   ```

   :::

   > [!IMPORTANT]
   > 用函数创建 SSRApp 可以避免跨请求状态污染；每次请求都生成一个独立实例

3. 从 Vue 到字符串 HTML

   在 Node 端用 `@vue/server-renderer` 提供的 `renderToString` 把应用实例渲染为 HTML 字符串

   :::code-tabs
   @tab src/index.js

   ```js
   const pino = require('pino');
   const express = require('express');
   const createApp = require('../frontend/main').default;

   const { resolve } = require('path');
   const { renderToString } = require('@vue/server-renderer');

   const app = express();
   const logger = pino();

   app.get('/', async (req, res) => {
     let { app: vueApp } = createApp();
     let appString = await renderToString(vueApp);

     res.send(
       `
       <!DOCTYPE html>
       <html lang="en">
       <head>
         <meta charset="UTF-8">
         <meta name="viewport" content="width=device-width, initial-scale=1.0">
         <title>Document</title>
       </head>
       <body>
         <div id="app">${appString}</div>
       </body>
       </html>
       `,
     );
   });

   app.listen(9999, () => {
     logger.info('Server is running at http://localhost:9999');
   });
   ```

   :::

   ==此时渲染的内容并不可交互，因为此时还没有进入到激活模式[+激活模式]==，因此接下来要做的是让 HTML 变得可交互，这一步就是 Hydration

4. Hydration

   Hydration 的作用正是让客户端接管这份 HTML，在复用已有 DOM 的前提下，为页面绑定事件与响应式逻辑，使其成为一个真正可交互的应用
   
   服务端输出的 HTML 中需要额外引入客户端 bundle

   :::code-tabs
   @tab src/index.js

   ```js
   const pino = require('pino');
   const express = require('express');
   const createApp = require('../frontend/main').default;

   const { resolve } = require('path');
   const { renderToString } = require('@vue/server-renderer');

   const app = express();
   const logger = pino();

   app.use('/client', express.static(resolve(__dirname, '../dist/client'))); // [!code ++]

   app.get('/', async (req, res) => {
     let { app: vueApp } = createApp();
     let appString = await renderToString(vueApp);

     res.send(
       [
         '<!DOCTYPE html>',
         '<body>',
         '<div id="app">' + appString + '</div>',
         '<script src="/client/client_bundle.js"></script>', // [!code ++]
         '</body>',
       ].join('\n'),
     );
   });

   app.listen(9999, () => {
     logger.info('Server is running at http://localhost:9999');
   });
   ```

   :::

   为了避免 hydration mismatch，首屏渲染必须保持一致，涉及浏览器专有 API 的逻辑放到 `mounted` 之后再执行。

5. 路由的实现

6. Store 的实现



::::
