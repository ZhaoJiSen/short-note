---
title: 数据获取
createTime: 2026/01/29 23:12:17
permalink: /vue/9fd9p11m/
---

> [!IMPORTANT]
> 本文基于 Nuxt 4（`app/*` 目录结构）
> `useFetch / useAsyncData` 用于 **SSR 友好的首屏数据获取**，`$fetch` 常用于 **事件触发请求**
> 在页面 `setup` 的首屏数据场景中直接使用 `$fetch` 会导致 SSR + CSR 双次请求

:::details 最佳实践
1. 首屏数据使用 `await useFetch` 或 `await useAsyncData`，不要单独用 `$fetch`
2. 需要依赖 `route`/`query` 的请求要使用响应式参数或 `watch`
3. 请求尽量设置 `key`，方便缓存与 `refreshNuxtData`
4. 只在客户端执行的请求加 `server: false` 或 `.client` 文件
5. 合并多请求用 `useAsyncData + Promise.all`，减少瀑布式加载
6. 统一在 `onResponseError` 做鉴权与错误处理
:::

## 核心概念

### 三种请求方式

[+useFetch]: 基于 `$fetch` 的 SSR 友好封装，适合页面数据  
[+useAsyncData]: SSR 友好封装，适合任意异步函数  
[+$fetch]: 通用请求工具，适合按钮点击、表单提交等 **事件触发**

### SSR / CSR 执行差异

- **服务端**：`await useFetch/useAsyncData` 会阻塞渲染，首屏直接有数据
- **客户端**：Hydration 后请求会复用服务端数据（避免双请求）
- **结论**：页面首屏数据在 `setup` 里优先使用 `useFetch/useAsyncData`

### 缓存与刷新

- `useFetch/useAsyncData` 会基于 `key` 缓存数据
- 使用 `useNuxtData(key)` 读取缓存
- 使用 `refreshNuxtData(key)` 触发统一刷新

## useFetch（推荐）

```vue
<script setup lang="ts">
const page = ref(1)

const { data, status, error, refresh } = await useFetch('/api/posts', {
  query: { page },
  // key 用于缓存与刷新
  key: 'posts-list',
  // 只在客户端请求时可用的控制
  lazy: false,
})
</script>

<template>
  <section>
    <p v-if="status === 'pending'">加载中...</p>
    <p v-else-if="error">请求失败：{{ error.message }}</p>
    <ul v-else>
      <li v-for="post in data" :key="post.id">{{ post.title }}</li>
    </ul>
    <button @click="refresh">手动刷新</button>
  </section>
</template>
```

## useAsyncData（多请求 / 自定义逻辑）

```vue
<script setup lang="ts">
const { data } = await useAsyncData('dashboard', async () => {
  const [users, orders] = await Promise.all([
    $fetch('/api/users'),
    $fetch('/api/orders'),
  ])

  // 返回任意结构
  return { users, orders }
})
</script>
```

## $fetch（事件触发）

```vue
<script setup lang="ts">
const loading = ref(false)

async function submitForm() {
  loading.value = true
  try {
    await $fetch('/api/feedback', {
      method: 'POST',
      body: { content: 'good job' },
    })
  } finally {
    loading.value = false
  }
}
</script>
```

## 请求拦截（统一鉴权 / 错误处理）

```ts
const { data } = await useFetch('/api/user', {
  onRequest({ options }) {
    const token = useCookie<string | null>('token')
    if (token.value) {
      const headers = new Headers(options.headers)
      headers.set('Authorization', `Bearer ${token.value}`)
      options.headers = headers
    }
  },
  onResponseError({ response }) {
    if (response.status === 401 && import.meta.client) {
      navigateTo('/login')
    }
  },
})
```

## SSR 透传 Headers

在服务端请求需要带 Cookie 时：

```vue
<script setup lang="ts">
const headers = useRequestHeaders(['cookie'])
const { data } = await useFetch('/api/user', { headers })
</script>
```

## 示例：商品列表 + 详情页（完整示例）

::::steps

1. 准备目录结构

   ::: file-tree
   - server
     - api
       - products.get.ts
       - products
         - [id].get.ts
   - app
     - pages
       - products
         - index.vue
         - [id].vue
   :::

2. 列表接口

   :::code-tabs
   @tab server/api/products.get.ts
   ```ts
   export default defineEventHandler((event) => {
     const query = getQuery(event)
     const keyword = String(query.q || '')

     const list = [
       { id: 1, name: 'Keyboard' },
       { id: 2, name: 'Mouse' },
     ].filter(item => item.name.toLowerCase().includes(keyword.toLowerCase()))

     return list
   })
   ```
   :::

3. 详情接口

   :::code-tabs
   @tab server/api/products/[id].get.ts
   ```ts
   export default defineEventHandler((event) => {
     const { id } = event.context.params as { id: string }

     return {
       id: Number(id),
       name: 'Keyboard',
       price: 199,
     }
   })
   ```
   :::

4. 列表页（useFetch + query）

   :::code-tabs
   @tab app/pages/products/index.vue
   ```vue
   <script setup lang="ts">
   const keyword = ref('')

   const { data, status, refresh } = await useFetch('/api/products', {
     query: { q: keyword },
     key: 'products',
     watch: [keyword],
   })
   </script>

   <template>
     <section>
       <input v-model="keyword" placeholder="Search" />
       <button @click="refresh">刷新</button>

       <p v-if="status === 'pending'">加载中...</p>
       <ul v-else>
         <li v-for="item in data" :key="item.id">
           <NuxtLink :to="`/products/${item.id}`">{{ item.name }}</NuxtLink>
         </li>
       </ul>
     </section>
   </template>
   ```
   :::

5. 详情页（useAsyncData）

   :::code-tabs
   @tab app/pages/products/[id].vue
   ```vue
   <script setup lang="ts">
   const route = useRoute()

   const { data } = await useAsyncData(
     () => `product-${route.params.id}`,
     () => $fetch(`/api/products/${route.params.id}`),
   )
   </script>

   <template>
     <section>
       <h1>{{ data?.name }}</h1>
       <p>价格：{{ data?.price }}</p>
     </section>
   </template>
   ```
   :::
::::

## 常见错误

### 错误 1：在 `setup` 中用 `$fetch` 拉首屏数据

表现：服务端与客户端各请求一次。  
修正：改用 `useFetch` 或 `useAsyncData`。

### 错误 2：未使用 `useRequestHeaders` 导致 SSR 丢失 Cookie

表现：服务端请求缺少登录态。  
修正：使用 `const headers = useRequestHeaders(['cookie'])`。

### 错误 3：响应式参数未触发更新

表现：`keyword` 改变但数据不刷新。  
修正：在 `useFetch` 中使用 `watch` 或响应式 `query`。
