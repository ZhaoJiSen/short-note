---
title: 序列化与反序列化
createTime: 2025/12/16 21:39:14
permalink: /rust/lb8818b7/
---

## serde

Rust 的通用序列化/反序列化框架，核心 crate 只定义 `Serialize`/`Deserialize` trait 和派生宏；具体格式由 `serde_json`、`toml`、`serde_yaml` 等实现

> [!NOTE]
> - 序列化：对象 -> JSON/字节流/文本
> - 反序列化：JSON/字节流/文本 -> 对象

::: details 用法
- Cargo 里开启派生：`serde = { version = "1", features = ["derive"] }`
- 数据结构上 `#[derive(Serialize, Deserialize)]` 即可让它能与任意 serde 支持的格式互转
- `#[serde(rename_all = "...")]`、`#[serde(rename = "...")]` 控制字段/变体名；`default`、`skip_serializing_if`、`flatten` 等属性用于自定义输入输出
- 泛型读写通常接受/返回 `T: Serialize` 或 `T: DeserializeOwned`（完全拥有数据）
:::

:::code-tabs
@tab 基本使用
```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
struct Config {
    name: String,
    port: u16,
    features: Vec<String>,
    // 未提供时填充默认值
    #[serde(default)]
    enabled: bool,
    // None 时不序列化该字段
    #[serde(skip_serializing_if = "Option::is_none")]
    note: Option<String>,
}

fn roundtrip(json: &str) -> serde_json::Result<String> {
    // 反序列化
    let cfg: Config = serde_json::from_str(json)?;
    // 再序列化为漂亮格式
    serde_json::to_string_pretty(&cfg)
}
```

@tab 常用属性
```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

fn default_port() -> u16 {
    8080
}

#[derive(Debug, Serialize, Deserialize)]
struct Service {
    // 单字段重命名
    #[serde(rename = "serviceName")]
    name: String,

    // 指定默认值函数
    #[serde(default = "default_port")]
    port: u16,

    // 透明展开嵌套 map，合并到同一层
    #[serde(flatten)]
    metadata: HashMap<String, String>,
}
```
:::

## serde_json

JSON 的官方实现，提供字符串/reader/writer 三种入口，以及 `Value` 动态类型和 `json!` 宏

::: details 用法
- `to_string[_pretty]` / `from_str` 适合内存字符串；`to_vec[_pretty]` / `from_slice` 适合网络缓冲区
- `to_writer[_pretty]` / `from_reader` 可直接对接文件或流，避免中间字符串拷贝
- `to_value` / `from_value` 在强类型与 `serde_json::Value` 之间转换
- 动态场景用 `serde_json::Value`，可通过 `json!` 宏构造、索引修改，再转换为强类型
:::

:::code-tabs
@tab 读写文件
```rust
use serde::{Deserialize, Serialize};
use serde_json;
use std::fs::File;
use std::io::{BufReader, BufWriter};

#[derive(Debug, Serialize, Deserialize)]
struct Config {
    name: String,
    port: u16,
}

fn load_config(path: &str) -> serde_json::Result<Config> {
    let reader = BufReader::new(File::open(path)?);
    serde_json::from_reader(reader)
}

fn save_config(path: &str, cfg: &Config) -> serde_json::Result<()> {
    let writer = BufWriter::new(File::create(path)?);
    serde_json::to_writer_pretty(writer, cfg)
}
```

@tab 操作 Value
```rust
use serde_json::{json, Value};

fn patch_user(mut v: Value) -> Value {
    // 通过宏构造并修改动态字段
    v["user"]["age"] = Value::from(30);
    v["user"]["tags"] = json!(["rust", "serde"]);
    v
}
```
:::

## 属性速查

- `rename_all = "camelCase" | "snake_case" | "kebab-case" | "SCREAMING_SNAKE_CASE"`：批量命名约定
- `default` / `default = "fn"`：缺省值填充；配合 `Option` 可容错旧字段缺失
- `skip_serializing_if = "predicate"`：条件跳过序列化（常用 `Option::is_none`, `Vec::is_empty`）
- `flatten`：把嵌套的 struct / map 展开到同一层，兼容未知字段
- `with = "module"` / `serialize_with` / `deserialize_with`：走自定义序列化逻辑，例如处理时间戳、base64 等特例

## feature 速查

- serde：默认 `std`；常用可选 `derive`（派生宏）、`alloc`（无 std 环境）、`rc`（支持 Rc/Arc）、`unstable`（夜间特性）
- serde_json：默认 `std`；可选 `alloc`（无 std 环境）、`raw_value`（延迟解析 Value）、`arbitrary_precision`（高精度数字）、`unbounded_depth`（禁用嵌套深度限制）

案例
```rust
use anyhow::Result;
use axum::{
    Json, Router,
    http::StatusCode,
    routing::{get, post},
};
use serde::{Deserialize, Serialize};

#[derive(Deserialize)]
struct CreateUser {
    username: String,
}

#[derive(Serialize)]
struct User {
    id: u64,
    username: String,
}

async fn root() -> &'static str {
    "Hello World!"
}

async fn create_user(Json(payload): Json<CreateUser>) -> (StatusCode, Json<User>) {
    let user = User {
        id: 123,
        username: payload.username,
    };

    (StatusCode::CREATED, Json(user))
}

#[tokio::main]
async fn main() -> Result<()> {
    let app = Router::new()
        .route("/", get(root))
        .route("/users", post(create_user));

    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000").await?;
    axum::serve(listener, app).await?;

    Ok(())
}

```
