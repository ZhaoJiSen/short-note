---
title: 基本概念
createTime: 2025/09/26 17:41:22
permalink: /rust/kf7myiln/
---

**所有权**，是 Rust 用于如何管理内存的一组规则。Rust 通过所有权机制管理内存，编译器在编译时会根据一系列的规则进行检查。若违反了任何这些规则，程序将无法编译

::: details 所有权与 GC
- Rust 语言本身没有 GC ，内存管理完全 依赖所有权、借用、生命周期的编译期检查，以及作用域结束时的 `Drop`（RAII）来释放资源
- 相比 GC 语言，所有权模型是静态检查 + 确定性析构，没有额外的 GC 线程或停顿开销
:::

> [!IMPORTANT]
> 所有权规则: 
> - Rust 中的每一个值都有一个所有者
> - 值在任一时刻有且只有一个所有者
> - 当所有者离开作用域，这个值将被丢弃

## 变量作用域

[+自定义析构]:
  指编译器会在值离开作用域时自动调用该类型实现的 `drop(&mut self)` 方法，用于关闭文件、释放堆内存、解锁等资源清理操作

作用域（scope）决定了变量的可见范围，以及它何时被自动清理。离开作用域时，值会被丢弃：若类型实现了 `Drop` 则调用自定义析构[+自定义析构]，否则按字段递归销毁

::: details Drop

`Drop` 只有在类型需要自定义清理逻辑时才会实现；不需要特殊清理的类型（标量、引用、纯 `Copy` 组合类型）通常不实现 `Drop`。一旦实现了 `Drop`，类型就不能是 `Copy`，二者互斥。

- 实现 `Drop` 的类型：`String`、`Vec`、`HashMap`、`Box`、`Rc`/`Arc`、`Mutex` 等包装堆/系统资源的类型，需要在作用域结束时释放内存、关闭句柄或解锁。
- 不实现 `Drop` 的类型：整数、浮点、布尔、字符、引用，以及只包含这些的元组/数组/切片。它们离开作用域同样会被丢弃，只是没有自定义逻辑。
- 只有显式使用 `std::mem::forget`、`Box::leak`、`ManuallyDrop` 等才会刻意跳过丢弃流程。

:::

```rust
fn main() {
    { // 作用域开始
        let s = String::from("hello"); // s 有效
        println!("{s}");
    } // 作用域结束，s 被丢弃，底层内存释放

    let x = 5; // 像 i32 这样的 Copy 类型，离开作用域只是栈上值的清理
    println!("{x}");
}
```

> [!NOTE]
> - 每个大括号 `{} ` 都会形成新作用域，`let` 绑定的生命周期随作用域结束而结束
> - 所有权转移（move）后，原变量在其作用域内也不再可用
